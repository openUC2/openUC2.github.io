"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[6227],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),c=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return i.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(t),d=a,g=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return t?i.createElement(g,r(r({ref:n},p),{},{components:t})):i.createElement(g,r({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=t[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},63481:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=t(87462),a=(t(67294),t(3905));const o={},r="UC2-REST Getting Started Tutorial",l={unversionedId:"ImSwitch/Advanced/Tutorials/UC2-REST-Getting-Started",id:"ImSwitch/Advanced/Tutorials/UC2-REST-Getting-Started",title:"UC2-REST Getting Started Tutorial",description:"UC2-REST is the Python library that provides a high-level interface for communicating with UC2-ESP32 firmware. This tutorial guides you through installation, setup, and basic usage of UC2-REST.",source:"@site/docs/05_ImSwitch/Advanced/04_Tutorials/UC2-REST-Getting-Started.md",sourceDirName:"05_ImSwitch/Advanced/04_Tutorials",slug:"/ImSwitch/Advanced/Tutorials/UC2-REST-Getting-Started",permalink:"/docs/ImSwitch/Advanced/Tutorials/UC2-REST-Getting-Started",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"UC2-ESP32 Getting Started Tutorial",permalink:"/docs/ImSwitch/Advanced/Tutorials/UC2-ESP-Getting-Started"},next:{title:"Device-Specific Guides",permalink:"/docs/ImSwitch/Advanced/Device-Specific/"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Architecture",id:"architecture",level:3},{value:"Installation",id:"installation",level:2},{value:"Method 1: pip Install (Recommended)",id:"method-1-pip-install-recommended",level:3},{value:"Method 2: Source Installation",id:"method-2-source-installation",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Connection",id:"basic-connection",level:3},{value:"First Commands",id:"first-commands",level:3},{value:"Hardware Control Modules",id:"hardware-control-modules",level:2},{value:"Motor Control",id:"motor-control",level:3},{value:"LED and Laser Control",id:"led-and-laser-control",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Custom Control Sequences",id:"custom-control-sequences",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"ImSwitch Integration",id:"imswitch-integration",level:3},{value:"Jupyter Notebook Integration",id:"jupyter-notebook-integration",level:3},{value:"Troubleshooting Guide",id:"troubleshooting-guide",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Debug Mode",id:"debug-mode",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Resources",id:"resources",level:2}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"uc2-rest-getting-started-tutorial"},"UC2-REST Getting Started Tutorial"),(0,a.kt)("p",null,"UC2-REST is the Python library that provides a high-level interface for communicating with UC2-ESP32 firmware. This tutorial guides you through installation, setup, and basic usage of UC2-REST."),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"UC2-REST serves as the communication layer between:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Python applications")," (including ImSwitch)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"UC2-ESP32 firmware")," running on microcontrollers"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Hardware components")," (motors, LEDs, cameras, sensors)")),(0,a.kt)("h3",{id:"key-features"},"Key Features"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Dual Communication"),": USB Serial and WiFi/HTTP support"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Object-Oriented API"),": Intuitive Python interface"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Error Handling"),": Robust error detection and recovery"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Real-time Control"),": Low-latency hardware communication"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ImSwitch Integration"),": Native support for ImSwitch workflows")),(0,a.kt)("h3",{id:"architecture"},"Architecture"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Python Application \u2190\u2192 UC2-REST \u2190\u2192 [USB/WiFi] \u2190\u2192 UC2-ESP32 \u2190\u2192 Hardware\n")),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("h3",{id:"method-1-pip-install-recommended"},"Method 1: pip Install (Recommended)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Install from PyPI (when available)\npip install UC2-REST\n\n# Or install latest development version\npip install git+https://github.com/openUC2/UC2-REST.git\n")),(0,a.kt)("h3",{id:"method-2-source-installation"},"Method 2: Source Installation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Clone repository\ngit clone https://github.com/openUC2/UC2-REST.git\ncd UC2-REST\n\n# Install in development mode\npip install -e .\n\n# Or install requirements and use directly\npip install -r requirements.txt\n")),(0,a.kt)("h2",{id:"quick-start"},"Quick Start"),(0,a.kt)("h3",{id:"basic-connection"},"Basic Connection"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'from UC2REST import UC2Client\nimport time\n\n# USB Serial connection\nclient = UC2Client(serialport="/dev/ttyUSB0", baudrate=115200)\n\n# Or WiFi connection\n# client = UC2Client(host="192.168.1.100", port=31950)\n\n# Check connection\nif client.is_connected:\n    print("\u2713 Connected to UC2-ESP32")\nelse:\n    print("\u2717 Connection failed")\n    exit(1)\n')),(0,a.kt)("h3",{id:"first-commands"},"First Commands"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Get system status\ntry:\n    status = client.state.get_state()\n    print(f"System status: {status}")\nexcept Exception as e:\n    print(f"Error getting status: {e}")\n\n# Test LED control\ntry:\n    # Turn LED on\n    client.led.set_led(channel=1, intensity=100)\n    print("LED turned on")\n    \n    time.sleep(2)\n    \n    # Turn LED off\n    client.led.set_led(channel=1, intensity=0)\n    print("LED turned off")\n    \nexcept Exception as e:\n    print(f"LED control error: {e}")\n')),(0,a.kt)("h2",{id:"hardware-control-modules"},"Hardware Control Modules"),(0,a.kt)("h3",{id:"motor-control"},"Motor Control"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class MotorController:\n    def __init__(self, client):\n        self.client = client\n        \n    def basic_movement(self):\n        """Basic motor movement examples"""\n        # Move X axis\n        print("Moving X axis...")\n        self.client.stage.move_x(steps=1000)\n        time.sleep(2)\n        \n        # Move Y axis\n        print("Moving Y axis...")\n        self.client.stage.move_y(steps=1000)\n        time.sleep(2)\n        \n        # Move Z axis (focus)\n        print("Moving Z axis...")\n        self.client.stage.move_z(steps=500)\n        time.sleep(2)\n        \n    def multi_axis_movement(self):\n        """Simultaneous multi-axis movement"""\n        print("Moving XYZ simultaneously...")\n        self.client.stage.move_xyz(x=500, y=500, z=100)\n        time.sleep(3)\n        \n    def homing_procedure(self):\n        """Home all axes"""\n        print("Homing all axes...")\n        self.client.stage.home_xyz()\n        time.sleep(10)  # Wait for homing to complete\n        \n        # Get position after homing\n        position = self.client.stage.get_position()\n        print(f"Position after homing: {position}")\n        \n    def precise_positioning(self):\n        """Precise absolute positioning"""\n        # Set absolute position (requires homing first)\n        target_position = {"x": 2000, "y": 1500, "z": 800}\n        print(f"Moving to position: {target_position}")\n        \n        self.client.stage.set_position(**target_position)\n        time.sleep(3)\n        \n        # Verify position\n        actual_position = self.client.stage.get_position()\n        print(f"Actual position: {actual_position}")\n\n# Usage\nmotor_controller = MotorController(client)\nmotor_controller.basic_movement()\n')),(0,a.kt)("h3",{id:"led-and-laser-control"},"LED and Laser Control"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class IlluminationController:\n    def __init__(self, client):\n        self.client = client\n        \n    def single_led_control(self):\n        """Control individual LEDs"""\n        # Test each LED channel\n        for channel in range(4):  # Assuming 4 LED channels\n            print(f"Testing LED channel {channel}")\n            \n            # Gradually increase intensity\n            for intensity in range(0, 101, 25):\n                self.client.led.set_led(channel=channel, intensity=intensity)\n                time.sleep(0.5)\n            \n            # Turn off\n            self.client.led.set_led(channel=channel, intensity=0)\n            time.sleep(0.5)\n    \n    def led_array_patterns(self):\n        """Control LED arrays/matrices"""\n        # Set all LEDs to same intensity\n        intensities = [50] * 8  # 8-channel LED array\n        self.client.led.set_led_array(intensities)\n        time.sleep(2)\n        \n        # Create pattern\n        pattern = [100, 0, 100, 0, 100, 0, 100, 0]\n        self.client.led.set_led_array(pattern)\n        time.sleep(2)\n        \n        # Turn all off\n        self.client.led.set_led_array([0] * 8)\n    \n    def laser_control(self):\n        """Laser control with safety measures"""\n        # Safety check before turning on laser\n        print("\u26a0\ufe0f  Laser safety check - ensure proper eye protection!")\n        input("Press Enter to continue with laser test...")\n        \n        try:\n            # Turn on laser at low power\n            self.client.laser.set_laser(channel=1, intensity=10)\n            print("Laser on at 10% power")\n            time.sleep(1)\n            \n            # Increase power gradually\n            for power in [25, 50]:\n                self.client.laser.set_laser(channel=1, intensity=power)\n                print(f"Laser power: {power}%")\n                time.sleep(1)\n            \n            # Turn off laser\n            self.client.laser.set_laser(channel=1, intensity=0)\n            print("Laser turned off")\n            \n        except Exception as e:\n            # Emergency shutdown\n            self.client.laser.turn_off_all()\n            print(f"Laser error - emergency shutdown: {e}")\n    \n    def synchronized_illumination(self):\n        """Coordinate multiple illumination sources"""\n        # Multi-channel fluorescence setup\n        channels = {\n            "DAPI": {"channel": 1, "intensity": 75},\n            "GFP": {"channel": 2, "intensity": 50},\n            "RFP": {"channel": 3, "intensity": 60}\n        }\n        \n        for name, config in channels.items():\n            print(f"Setting up {name} channel...")\n            self.client.led.set_led(\n                channel=config["channel"], \n                intensity=config["intensity"]\n            )\n            time.sleep(0.5)\n        \n        # Turn all off\n        for config in channels.values():\n            self.client.led.set_led(channel=config["channel"], intensity=0)\n\n# Usage\nillum_controller = IlluminationController(client)\nillum_controller.single_led_control()\n')),(0,a.kt)("h2",{id:"advanced-usage"},"Advanced Usage"),(0,a.kt)("h3",{id:"custom-control-sequences"},"Custom Control Sequences"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class AdvancedController:\n    def __init__(self, client):\n        self.client = client\n        \n    def automated_scan_sequence(self, scan_params):\n        """Automated scanning with coordinated hardware control"""\n        # Parameters\n        x_range = scan_params.get("x_range", (0, 5000, 500))  # start, end, step\n        y_range = scan_params.get("y_range", (0, 5000, 500))\n        led_intensity = scan_params.get("led_intensity", 75)\n        settle_time = scan_params.get("settle_time", 0.5)\n        \n        print("Starting automated scan sequence...")\n        \n        # Setup illumination\n        self.client.led.set_led(channel=1, intensity=led_intensity)\n        \n        scan_positions = []\n        \n        try:\n            # Generate scan positions\n            for x in range(*x_range):\n                for y in range(*y_range):\n                    # Move to position\n                    self.client.stage.move_to_position(x=x, y=y)\n                    time.sleep(settle_time)\n                    \n                    # Record position\n                    actual_pos = self.client.stage.get_position()\n                    scan_positions.append(actual_pos)\n                    \n                    print(f"Scanned position: X={actual_pos[\'x\']}, Y={actual_pos[\'y\']}")\n                    \n                    # Optional: trigger camera acquisition here\n                    # camera.acquire_image()\n                    \n        except KeyboardInterrupt:\n            print("Scan interrupted by user")\n            \n        finally:\n            # Cleanup\n            self.client.led.set_led(channel=1, intensity=0)\n            print(f"Scan complete. Visited {len(scan_positions)} positions.")\n            \n        return scan_positions\n    \n    def focus_stack_acquisition(self, z_params):\n        """Automated focus stacking"""\n        z_start = z_params.get("z_start", 0)\n        z_end = z_params.get("z_end", 1000)\n        z_step = z_params.get("z_step", 50)\n        \n        focus_positions = []\n        \n        print("Starting focus stack acquisition...")\n        \n        for z in range(z_start, z_end + z_step, z_step):\n            # Move to Z position\n            self.client.stage.set_position(z=z)\n            time.sleep(0.5)  # Allow settling\n            \n            # Verify position\n            actual_z = self.client.stage.get_position()["z"]\n            focus_positions.append(actual_z)\n            \n            print(f"Focus position: Z={actual_z}")\n            \n            # Optional: acquire image at this focus level\n            # image = camera.acquire_image()\n            # save_image(image, f"focus_z_{actual_z}.tif")\n            \n        print(f"Focus stack complete. {len(focus_positions)} levels acquired.")\n        return focus_positions\n    \n    def multi_channel_protocol(self, channels):\n        """Multi-channel imaging protocol"""\n        # Example channels configuration\n        # channels = [\n        #     {"name": "DAPI", "led_channel": 1, "intensity": 75, "exposure": 100},\n        #     {"name": "GFP", "led_channel": 2, "intensity": 50, "exposure": 200},\n        #     {"name": "RFP", "led_channel": 3, "intensity": 60, "exposure": 150}\n        # ]\n        \n        for channel_config in channels:\n            name = channel_config["name"]\n            led_channel = channel_config["led_channel"]\n            intensity = channel_config["intensity"]\n            \n            print(f"Acquiring {name} channel...")\n            \n            # Set illumination\n            self.client.led.set_led(channel=led_channel, intensity=intensity)\n            time.sleep(0.1)  # Brief stabilization\n            \n            # Optional: set camera exposure\n            # camera.set_exposure(channel_config["exposure"])\n            \n            # Acquire image\n            # image = camera.acquire_image()\n            # save_image(image, f"{name}_channel.tif")\n            \n            # Turn off illumination\n            self.client.led.set_led(channel=led_channel, intensity=0)\n            time.sleep(0.1)\n            \n        print("Multi-channel acquisition complete")\n\n# Usage\nadvanced_controller = AdvancedController(client)\n\n# Example scan\nscan_params = {\n    "x_range": (0, 2000, 200),\n    "y_range": (0, 2000, 200),\n    "led_intensity": 75,\n    "settle_time": 0.3\n}\npositions = advanced_controller.automated_scan_sequence(scan_params)\n')),(0,a.kt)("h2",{id:"integration-examples"},"Integration Examples"),(0,a.kt)("h3",{id:"imswitch-integration"},"ImSwitch Integration"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# UC2-REST is automatically integrated with ImSwitch\n# Configuration in ImSwitch JSON file:\n\nimswitch_config = {\n    "rs232devices": {\n        "ESP32": {\n            "managerName": "ESP32Manager",\n            "managerProperties": {\n                "serialport": "/dev/ttyUSB0",\n                "host_": "192.168.1.100"  # Optional: for WiFi\n            }\n        }\n    },\n    "positioners": {\n        "ESP32Stage": {\n            "managerName": "ESP32StageManager",\n            "managerProperties": {\n                "rs232device": "ESP32"\n            },\n            "axes": ["X", "Y", "Z"],\n            "forScanning": True\n        }\n    }\n}\n')),(0,a.kt)("h3",{id:"jupyter-notebook-integration"},"Jupyter Notebook Integration"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Example Jupyter notebook cell\nfrom UC2REST import UC2Client\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Connect to hardware\nclient = UC2Client(serialport="/dev/ttyUSB0")\n\n# Interactive control\ndef move_stage(x=0, y=0, z=0):\n    """Interactive stage control for Jupyter"""\n    client.stage.move_xyz(x=x, y=y, z=z)\n    pos = client.stage.get_position()\n    print(f"New position: {pos}")\n\n# Create interactive widgets (requires ipywidgets)\nfrom ipywidgets import interact\ninteract(move_stage, x=(-5000, 5000, 100), y=(-5000, 5000, 100), z=(-1000, 1000, 50))\n')),(0,a.kt)("h2",{id:"troubleshooting-guide"},"Troubleshooting Guide"),(0,a.kt)("h3",{id:"common-issues-and-solutions"},"Common Issues and Solutions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def diagnostic_check(client):\n    """Comprehensive diagnostic check"""\n    print("UC2-REST Diagnostic Check")\n    print("=" * 30)\n    \n    # 1. Connection test\n    if client.is_connected:\n        print("\u2713 Connection: OK")\n    else:\n        print("\u2717 Connection: FAILED")\n        return False\n    \n    # 2. Communication test\n    try:\n        status = client.state.get_state()\n        print("\u2713 Communication: OK")\n    except Exception as e:\n        print(f"\u2717 Communication: FAILED - {e}")\n        return False\n    \n    # 3. Hardware test\n    try:\n        # Test LED\n        client.led.set_led(channel=1, intensity=50)\n        time.sleep(0.5)\n        client.led.set_led(channel=1, intensity=0)\n        print("\u2713 LED control: OK")\n        \n        # Test stage\n        original_pos = client.stage.get_position()\n        client.stage.move_x(100)\n        time.sleep(1)\n        client.stage.move_x(-100)\n        print("\u2713 Stage control: OK")\n        \n    except Exception as e:\n        print(f"\u2717 Hardware control: FAILED - {e}")\n        return False\n    \n    print("\u2713 All diagnostics passed!")\n    return True\n\n# Run diagnostics\nif client.is_connected:\n    diagnostic_check(client)\n')),(0,a.kt)("h3",{id:"debug-mode"},"Debug Mode"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Enable debug output for troubleshooting\nclient_debug = UC2Client(serialport="/dev/ttyUSB0", DEBUG=True)\n\n# All commands and responses will be printed\nclient_debug.stage.move_x(1000)\n# Output will show:\n# [DEBUG] Sending: {"task": "/motor_act", "motor": 0, "direction": 1, "steps": 1000}\n# [DEBUG] Received: {"return": 1, "task": "/motor_act", "motor": 0, "position": 1000}\n')),(0,a.kt)("h2",{id:"next-steps"},"Next Steps"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"/docs/ImSwitch/Advanced/Configuration/"},"ImSwitch Configuration"))," - Configure ImSwitch to use UC2-REST"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"/docs/ImSwitch/Advanced/Tutorials/UC2-ESP-Getting-Started"},"UC2-ESP32 Setup"))," - Set up the ESP32 firmware"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"./Scripting.md"},"Advanced Workflows"))," - Create custom automation scripts")),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"https://github.com/openUC2/UC2-REST"},"UC2-REST Repository"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"https://github.com/openUC2/UC2-REST/blob/master/docs/API.md"},"API Documentation"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"https://github.com/openUC2/UC2-REST/tree/master/examples"},"Example Scripts"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"https://openuc2.com"},"Community Forum")))))}u.isMDXComponent=!0}}]);