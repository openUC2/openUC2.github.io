"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[3052],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>g});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),c=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(a),g=r,k=m["".concat(o,".").concat(g)]||m[g]||u[g]||l;return a?n.createElement(k,i(i({ref:t},p),{},{components:a})):n.createElement(k,i({ref:t},p))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<l;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},28392:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const l={},i="UC2-REST: Messaging",s={unversionedId:"Electronics/UC2-REST/ESP32_Messaging_Callback",id:"Electronics/UC2-REST/ESP32_Messaging_Callback",title:"UC2-REST: Messaging",description:"This documentation covers the callback functionality integrated into the firmware, particularly focusing on the Message class. The Message class is designed to parse incoming messages from the ESP32, facilitating the conversion of hardware inputs and other events into software actions.",source:"@site/docs/03_Electronics/UC2-REST/ESP32_Messaging_Callback.md",sourceDirName:"03_Electronics/UC2-REST",slug:"/Electronics/UC2-REST/ESP32_Messaging_Callback",permalink:"/docs/Electronics/UC2-REST/ESP32_Messaging_Callback",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"UC2-REST",permalink:"/docs/Electronics/UC2-REST/INTRO"},next:{title:"UC2-REST: Motor",permalink:"/docs/Electronics/UC2-REST/ESP32_Motor"}},o={},c=[{value:"Message Class",id:"message-class",level:2},{value:"Constructor",id:"constructor",level:3},{value:"Registering Callbacks",id:"registering-callbacks",level:3},{value:"Callback Message Handler",id:"callback-message-handler",level:3},{value:"Example Usage",id:"example-usage",level:3}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"uc2-rest-messaging"},"UC2-REST: Messaging"),(0,r.kt)("p",null,"This documentation covers the callback functionality integrated into the firmware, particularly focusing on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Message")," class. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Message")," class is designed to parse incoming messages from the ESP32, facilitating the conversion of hardware inputs and other events into software actions."),(0,r.kt)("h2",{id:"message-class"},"Message Class"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Message")," class plays a pivotal role in handling incoming messages from the ESP32, allowing for events such as image capture or adjustments to hardware inputs to be managed through software events."),(0,r.kt)("h3",{id:"constructor"},"Constructor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(self, parent=None):\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"parent")," (optional): A reference to the parent object, typically used for accessing shared resources or methods."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Description:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Initializes the ",(0,r.kt)("inlineCode",{parentName:"li"},"Message")," object with an empty dictionary of callback functions and optionally sets up a callback for motor status if the parent object has a ",(0,r.kt)("inlineCode",{parentName:"li"},"serial")," attribute.")))),(0,r.kt)("h3",{id:"registering-callbacks"},"Registering Callbacks"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def register_callback(self, key, callback):\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key"),": The key associated with the message to trigger the callback."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"callback"),": The function to be called when a message with the specified key is received."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Description:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Associates a callback function with a specific key. When a message with this key is received, the specified callback function is triggered.")))),(0,r.kt)("h3",{id:"callback-message-handler"},"Callback Message Handler"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _callback_message(self, data):\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data"),": The incoming message data in JSON format."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Description:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Parses the incoming JSON message, extracting the key and data. If a callback function has been registered for the key, it is invoked with the message data.")))),(0,r.kt)("h3",{id:"example-usage"},"Example Usage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import uc2rest\nimport time\n\n# Initialize the UC2 client\nport = "/dev/cu.SLAB_USBtoUART"\nESP32 = uc2rest.UC2Client(serialport=port, baudrate=500000, DEBUG=True)\n\n# Define a callback function\ndef my_callback_key1(value):\n    print("Callback:", value)\n\n# Register the callback function for key 1\nESP32.message.register_callback(1, my_callback_key1)\n\n# Main loop to keep the script running\nwhile True:\n    time.sleep(.1)\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Description:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This example demonstrates how to set up the ESP32 client, register a callback function for a specific key, and enter a loop that keeps the script running to listen for messages.")))))}u.isMDXComponent=!0}}]);