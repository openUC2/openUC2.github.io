"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[9031],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=l(n),h=o,u=m["".concat(c,".").concat(h)]||m[h]||p[h]||r;return n?i.createElement(u,a(a({ref:t},d),{},{components:n})):i.createElement(u,a({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<r;l++)a[l]=n[l];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},73266:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var i=n(87462),o=(n(67294),n(3905));const r={},a="AS 5311 linear encoder for real-time feedback loop",s={unversionedId:"Electronics/Advanced/UC2-ESP/APIDescription/Encoder",id:"Electronics/Advanced/UC2-ESP/APIDescription/Encoder",title:"AS 5311 linear encoder for real-time feedback loop",description:"The relevant code can be found here:",source:"@site/docs/04_Electronics/10_Advanced/UC2-ESP/APIDescription/Encoder.md",sourceDirName:"04_Electronics/10_Advanced/UC2-ESP/APIDescription",slug:"/Electronics/Advanced/UC2-ESP/APIDescription/Encoder",permalink:"/docs/Electronics/Advanced/UC2-ESP/APIDescription/Encoder",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Digital Input",permalink:"/docs/Electronics/Advanced/UC2-ESP/APIDescription/DigitalInput"},next:{title:"Home",permalink:"/docs/Electronics/Advanced/UC2-ESP/APIDescription/Home"}},c={},l=[{value:"Electronic interface",id:"electronic-interface",level:3},{value:"Understanding the AS5311 Encoder",id:"understanding-the-as5311-encoder",level:3},{value:"Incorporating AS5311 into UC2-ESP Firmware",id:"incorporating-as5311-into-uc2-esp-firmware",level:3},{value:"Key Components of the Implementation",id:"key-components-of-the-implementation",level:3},{value:"Implementing Closed-Loop Control",id:"implementing-closed-loop-control",level:3},{value:"Practical Considerations",id:"practical-considerations",level:3},{value:"Control Interface",id:"control-interface",level:3},{value:"JSON Control Commands",id:"json-control-commands",level:3},{value:"1. Calibration (<code>/linearencoder_act</code>, <code>calpos</code>)",id:"1-calibration-linearencoder_act-calpos",level:4},{value:"2. Homing (<code>/linearencoder_act</code>, <code>home</code>)",id:"2-homing-linearencoder_act-home",level:4},{value:"3. Precise Movement (<code>/linearencoder_act</code>, <code>moveP</code>)",id:"3-precise-movement-linearencoder_act-movep",level:4},{value:"4. Get Current Position (<code>/linearencoder_get</code>)",id:"4-get-current-position-linearencoder_get",level:4},{value:"Summary and Conclusion",id:"summary-and-conclusion",level:3}],d={toc:l};function p(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,i.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"as-5311-linear-encoder-for-real-time-feedback-loop"},"AS 5311 linear encoder for real-time feedback loop"),(0,o.kt)("p",null,"The relevant code can be found here:\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/youseetoo/uc2-esp32/tree/reworkBD/main/src/encoder"},"https://github.com/youseetoo/uc2-esp32/tree/reworkBD/main/src/encoder")),(0,o.kt)("p",null,"Please file an issue in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/youseetoo/uc2-esp32/issues"},"https://github.com/youseetoo/uc2-esp32/issues")," repository. Thank or visit our forum ",(0,o.kt)("a",{parentName:"p",href:"https://openuc2.discourse.group/"},"https://openuc2.discourse.group/")," and ask a question. Someone may help you :)."),(0,o.kt)("p",null,"This tutorial will guide you through integrating and utilizing the AS5311 linear encoder within the UC2-ESP firmware, focusing on implementing closed-loop feedback control for precise motor positioning. The AS5311 is a high-resolution magnetic linear encoder designed for accurately measuring linear displacement. Our application within the UC2-ESP system demonstrates its use in a feedback loop with an integrated PID controller, enhancing the precision and reliability of stepper motor-driven mechanisms."),(0,o.kt)("p",null,"Feedback-loop in action:\n",(0,o.kt)("img",{src:n(32975).Z,width:"854",height:"480"})),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1489).Z,width:"960",height:"1280"}),"\n",(0,o.kt)("em",{parentName:"p"},"Where to mount the hall sensor")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(75971).Z,width:"864",height:"1233"}),"\n",(0,o.kt)("em",{parentName:"p"},"Magnetic Strip")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(85433).Z,width:"150",height:"192"}),"\n",(0,o.kt)("em",{parentName:"p"},"Reference design by AMS")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(96467).Z,width:"2090",height:"940"}),"\n",(0,o.kt)("em",{parentName:"p"},"First UC2 Prototype (more to come soon)")),(0,o.kt)("h3",{id:"electronic-interface"},"Electronic interface"),(0,o.kt)("p",null,"How to wire the UC2 AS5311 board to the UC2_V3 board?\n",(0,o.kt)("img",{src:n(65511).Z,width:"1582",height:"1080"})),(0,o.kt)("p",null,(0,o.kt)("a",{target:"_blank",href:n(22161).Z},"Here")," are the ESP32 pins:\n",(0,o.kt)("img",{src:n(82843).Z,width:"2024",height:"1440"})),(0,o.kt)("h3",{id:"understanding-the-as5311-encoder"},"Understanding the AS5311 Encoder"),(0,o.kt)("p",null,"The AS5311 operates based on magnetic principles, translating the movement of a magnetically encoded strip into digital signals. This encoder provides a resolution of 2mm per 1024 steps, meaning every 1024 increments in the encoder's output corresponds to a 2mm movement along the encoded strip. This high resolution enables precise control and measurement of linear motion, critical for applications requiring fine positioning accuracy."),(0,o.kt)("h3",{id:"incorporating-as5311-into-uc2-esp-firmware"},"Incorporating AS5311 into UC2-ESP Firmware"),(0,o.kt)("p",null,"The integration involves processing the encoder's digital output signals to determine the position and movement direction. This is accomplished by reading changes in the encoder's output pins and applying the calculated position changes to maintain a feedback loop. The feedback loop is crucial for the PID controller, which adjusts the motor's speed and direction to correct any position errors."),(0,o.kt)("p",null,"There are multiple interfaces to read out the actual value like PWM, digital readout and incremental mode. We have chosen the A/B incremental mode since this uses the least number of wires. We use the encoder ports on the ESP32 v3 board to ensure the usage of interrupts to count the position changes in time."),(0,o.kt)("h3",{id:"key-components-of-the-implementation"},"Key Components of the Implementation"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Encoder Event Processing:")," When an encoder output pin changes state, it triggers an interrupt. The firmware then determines the movement direction (forward or backward) by comparing the states of two encoder pins and adjusts the position accordingly."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PID Controller Integration:")," The PID controller calculates the necessary adjustments to the motor's speed based on the difference between the desired position and the current encoder position. This process involves precise tuning of the PID parameters (proportional, integral, derivative) to achieve optimal performance for specific hardware and motion requirements."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Serial Interface Commands:")," The firmware supports several commands over the serial interface for calibration, homing, precise movement, and current position queries. These commands allow for dynamic control and adjustment of the system's behavior.")),(0,o.kt)("h3",{id:"implementing-closed-loop-control"},"Implementing Closed-Loop Control"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Calibration:")," Before precise control is possible, calibrating the relationship between motor steps and physical displacement is necessary. This involves moving the motor a known number of steps and measuring the resulting displacement using the encoder."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Homing:")," The system can move the motor in one direction until it detects no further motion (indicating an endpoint) and then slightly retract to release any endstop engagement. This process sets a known reference point for subsequent movements."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Precise Movement:")," With the PID controller tuned, the system can move the motor to specific positions with high accuracy. The controller adjusts the motor speed in real-time to minimize position error, relying on continuous feedback from the encoder.")),(0,o.kt)("h3",{id:"practical-considerations"},"Practical Considerations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PID Tuning:")," Achieving the desired control performance requires careful tuning of the PID parameters, which may involve empirical testing and adjustments based on the specific characteristics of the motor and mechanical setup."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Calibration Accuracy:")," The precision of calibration directly affects the system's overall accuracy. Ensure consistent and accurate measurements during the calibration process.")),(0,o.kt)("h3",{id:"control-interface"},"Control Interface"),(0,o.kt)("p",null,"To effectively manage and interact with the linear position encoder and motor driver in the UC2-ESP system, a series of JSON-formatted strings are used. These strings serve as commands through the serial interface, allowing users to perform various actions such as calibration, homing, precise movement, and querying the current position. Below is a detailed explanation of each command type and its purpose within the system."),(0,o.kt)("h3",{id:"json-control-commands"},"JSON Control Commands"),(0,o.kt)("h4",{id:"1-calibration-linearencoder_act-calpos"},"1. Calibration (",(0,o.kt)("inlineCode",{parentName:"h4"},"/linearencoder_act"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"calpos"),")"),(0,o.kt)("p",null,"The calibration command is used to determine the precise relationship between the number of steps the motor takes and the physical displacement (in millimeters) as measured by the encoder. This is essential for ensuring accurate movements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "task": "/linearencoder_act",\n  "calpos": {\n    "steppers": [\n      {\n        "stepperid": 1,\n        "calibsteps": -32000,\n        "speed": 10000\n      }\n    ]\n  }\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"stepperid")," identifies the motor."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"calibsteps")," specifies the number of steps to move during calibration (negative for backward movement)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"speed")," defines the speed at which the motor should move during calibration.")),(0,o.kt)("h4",{id:"2-homing-linearencoder_act-home"},"2. Homing (",(0,o.kt)("inlineCode",{parentName:"h4"},"/linearencoder_act"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"home"),")"),(0,o.kt)("p",null,"The homing command moves the motor in one direction until it detects no further motion (suggesting it has hit an endpoint), then moves it slightly in the opposite direction to release any endstop. This process is used to establish a known reference position."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "task": "/linearencoder_act",\n  "home": {\n    "steppers": [\n      {\n        "stepperid": 1,\n        "endposrelease": -100,\n        "speed": -40000\n      }\n    ]\n  }\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"endposrelease")," indicates the number of steps to move back to slightly release the endstop."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"speed")," determines the speed of the homing motion. Negative values indicate direction.")),(0,o.kt)("h4",{id:"3-precise-movement-linearencoder_act-movep"},"3. Precise Movement (",(0,o.kt)("inlineCode",{parentName:"h4"},"/linearencoder_act"),", ",(0,o.kt)("inlineCode",{parentName:"h4"},"moveP"),")"),(0,o.kt)("p",null,"This command allows for moving the motor to a specific position with high precision, utilizing the PID controller for real-time adjustments based on encoder feedback."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "task": "/linearencoder_act",\n  "moveP": {\n    "steppers": [\n      {\n        "stepperid": 1,\n        "position": 1000,\n        "isabs": 1,\n        "cp": 100,\n        "ci": 0.0,\n        "cd": 10\n      }\n    ]\n  }\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"position")," specifies the target position in encoder units."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isabs")," indicates whether the position is absolute (",(0,o.kt)("inlineCode",{parentName:"li"},"1"),") or relative to the current position (",(0,o.kt)("inlineCode",{parentName:"li"},"0"),")."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cp"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"ci"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"cd")," are the PID controller parameters: proportional, integral, and derivative gains, respectively.")),(0,o.kt)("h4",{id:"4-get-current-position-linearencoder_get"},"4. Get Current Position (",(0,o.kt)("inlineCode",{parentName:"h4"},"/linearencoder_get"),")"),(0,o.kt)("p",null,"To query the current position of the motor as measured by the encoder, the following command is used:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "task": "/linearencoder_get",\n  "linencoder": {\n    "posval": 1,\n    "id": 1\n  }\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"posval")," is a flag to request the position value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"id")," identifies the encoder from which to read the position.")),(0,o.kt)("h3",{id:"summary-and-conclusion"},"Summary and Conclusion"),(0,o.kt)("p",null,"These JSON commands form a versatile interface for controlling and querying the state of the motor and encoder in the UC2-ESP system. By sending these commands over the serial interface, users can precisely calibrate the system, perform accurate movements, and retrieve current position information, enabling high-precision control over linear motion systems."),(0,o.kt)("p",null,"The integration of the AS5311 linear encoder into the UC2-ESP firmware exemplifies advanced control techniques enabling precise linear motion control. Through careful implementation of encoder feedback and PID control algorithms, this system achieves high levels of accuracy and reliability, suitable for a wide range of precision motion applications."))}p.isMDXComponent=!0},22161:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/files/UC2_V3_schematics-f06521883de66181ed9afffdbf067dbd.pdf"},32975:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/AS5311_4-a18582a4bb41daaa2d0f32f4426501f8.gif"},1489:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/as5311-a033eac4edd3d43ba6eefa556b45380b.jpeg"},75971:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/as5311_1-def82af897c1114644596dde8eb082ed.jpeg"},85433:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/as5311_2-66bf22543dbb98962b3aaa1cdfd24a11.jpeg"},96467:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/as5311_3-4e7d910170bbaa28cfd9533a8f0df840.jpeg"},65511:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/encoderinterface-51635c6563a540634324354c3013a2f3.png"},82843:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/image-15670e68f3b517a73003691533dd4dd6.png"}}]);