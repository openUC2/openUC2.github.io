"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[7270],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),g=r,f=d["".concat(s,".").concat(g)]||d[g]||c[g]||a;return n?i.createElement(f,o(o({ref:t},u),{},{components:n})):i.createElement(f,o({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<a;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},32161:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var i=n(87462),r=(n(67294),n(3905));const a={},o="UC2-ESP Digital Input API Documentation",l={unversionedId:"Electronics/UC2-ESP/APIDescription/DigitalIn",id:"Electronics/UC2-ESP/APIDescription/DigitalIn",title:"UC2-ESP Digital Input API Documentation",description:"The UC2-ESP firmware provides an API for managing digital input channels. This allows querying the state (high or low) of digital inputs which are useful for reading endstops, buttons, or other binary sensors.",source:"@site/docs/03_Electronics/UC2-ESP/APIDescription/DigitalIn.md",sourceDirName:"03_Electronics/UC2-ESP/APIDescription",slug:"/Electronics/UC2-ESP/APIDescription/DigitalIn",permalink:"/docs/Electronics/UC2-ESP/APIDescription/DigitalIn",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"UC2-ESP",permalink:"/docs/Electronics/UC2-ESP/APIDescription/INTRO"},next:{title:"AS 5311 linear encoder for real-time feedback loop",permalink:"/docs/Electronics/UC2-ESP/APIDescription/Encoder"}},s={},p=[{value:"Endpoint",id:"endpoint",level:2},{value:"Request Format",id:"request-format",level:2},{value:"JSON Parameters Description",id:"json-parameters-description",level:2},{value:"Example Request",id:"example-request",level:2},{value:"Response Format",id:"response-format",level:2},{value:"Endpoint for Actions (currently placeholder)",id:"endpoint-for-actions-currently-placeholder",level:2},{value:"Setup and Configuration",id:"setup-and-configuration",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"uc2-esp-digital-input-api-documentation"},"UC2-ESP Digital Input API Documentation"),(0,r.kt)("p",null,"The UC2-ESP firmware provides an API for managing digital input channels. This allows querying the state (high or low) of digital inputs which are useful for reading endstops, buttons, or other binary sensors."),(0,r.kt)("h2",{id:"endpoint"},"Endpoint"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Endpoint:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"/digitalin_get")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"/digitalin_get")," endpoint retrieves the current state of a specified digital input channel."),(0,r.kt)("h2",{id:"request-format"},"Request Format"),(0,r.kt)("p",null,"The API expects a JSON document structured as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "task": "/digitalin_get",\n  "qid": 1,\n  "digitalinid": 2\n}\n')),(0,r.kt)("h2",{id:"json-parameters-description"},"JSON Parameters Description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"task"),": Specifies the requested task, set to ",(0,r.kt)("inlineCode",{parentName:"li"},"/digitalin_get")," for querying digital input states."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"qid"),": (optional) Queue ID used to identify and track the request."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"digitalinid"),": The ID of the digital input channel to query (valid values are 1, 2, or 3).")),(0,r.kt)("h2",{id:"example-request"},"Example Request"),(0,r.kt)("p",null,"Query the state of digital input channel 2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"task": "/digitalin_get", "digitalinid":2}\n')),(0,r.kt)("h2",{id:"response-format"},"Response Format"),(0,r.kt)("p",null,"The response is a JSON object containing the digital input ID and its current value (0 or 1):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "digitalin": {\n    "digitalinid": 2,\n    "digitalinval": 1\n  }\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"digitalinid"),": Echoes the requested digital input channel ID."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"digitalinval"),": The current state of the digital input (0 for LOW, 1 for HIGH).")),(0,r.kt)("h2",{id:"endpoint-for-actions-currently-placeholder"},"Endpoint for Actions (currently placeholder)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Endpoint:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"/digitalin_act")),(0,r.kt)("p",null,"This endpoint currently acts as a placeholder for potential future functionality related to digital inputs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"task": "/digitalin_act", "qid":1}\n')),(0,r.kt)("p",null,"It returns the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"qid")," without additional actions."),(0,r.kt)("h2",{id:"setup-and-configuration"},"Setup and Configuration"),(0,r.kt)("p",null,"Digital inputs are configured with internal pull-down resistors by default (except when using external devices like the TCA9535 I/O expander, configured separately)."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"The UC2-ESP Digital Input API provides straightforward access to the states of digital inputs, essential for sensor integration and user interaction within automated and controlled experiments."))}c.isMDXComponent=!0}}]);