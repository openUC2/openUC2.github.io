"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[7235],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),m=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=m(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=m(a),u=r,h=d["".concat(s,".").concat(u)]||d[u]||p[u]||i;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var m=2;m<i;m++)o[m]=a[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},87191:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>m});var n=a(87462),r=(a(67294),a(3905));const i={},o=void 0,l={unversionedId:"Electronics/Advanced/CANInterface",id:"Electronics/Advanced/CANInterface",title:"CANInterface",description:"Overview of the CAN Communication Implementation (ISO-TP) inside UC2-ESP32",source:"@site/docs/03_Electronics/10_Advanced/13-CANInterface.md",sourceDirName:"03_Electronics/10_Advanced",slug:"/Electronics/Advanced/CANInterface",permalink:"/docs/Electronics/Advanced/CANInterface",draft:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"HAT+",permalink:"/docs/Electronics/Advanced/RaspberryPiHat+"},next:{title:"Python commands",permalink:"/docs/Electronics/Advanced/uc2e5.2"}},s={},m=[{value:"General Behaviour",id:"general-behaviour",level:2},{value:"Detailed information",id:"detailed-information",level:2},{value:"<strong>1. File Structure and Responsibilities</strong>",id:"1-file-structure-and-responsibilities",level:3},{value:"<strong>2. Driver Initialization (can_bus.cpp)</strong>",id:"2-driver-initialization-can_buscpp",level:3},{value:"<strong>3. ISO-TP Layer (can_communication.cpp)</strong>",id:"3-iso-tp-layer-can_communicationcpp",level:3},{value:"<strong>4. Message Routing and Handling</strong>",id:"4-message-routing-and-handling",level:3},{value:"<strong>5. Typical Flow</strong>",id:"5-typical-flow",level:3},{value:"<strong>6. Configuration Parameters (can_config.h)</strong>",id:"6-configuration-parameters-can_configh",level:3},{value:"<strong>7. Master/Slave CAN IDs</strong>",id:"7-masterslave-can-ids",level:3},{value:"<strong>8. Extending Commands</strong>",id:"8-extending-commands",level:3},{value:"<strong>9. Error Handling</strong>",id:"9-error-handling",level:3},{value:"<strong>10. Summary of Key Points</strong>",id:"10-summary-of-key-points",level:3}],c={toc:m};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Overview of the CAN Communication Implementation (ISO-TP) inside UC2-ESP32")),(0,r.kt)("p",null,"This library provides an ISO-TP\u2013based CAN interface for communication among various modules (motors, lasers, etc.) connected to the ESP32. At startup, the ESP32 brings all nodes to a known state (e.g., stopping motors), then collects status information (such as motor positions) via CAN. Though CAN itself lacks a strict \u201cmaster/slave\u201d concept, the ESP32 acts as a central controller by sending commands and processing status updates from any node. Whenever external input arrives (e.g., from a joystick), the library converts these commands into CAN messages that control motor speed or other device behavior."),(0,r.kt)("p",null,"The platformio firmware for the esp32 is here:\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src"},"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src")),(0,r.kt)("p",null,"Relevant files are in the folder\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src/can"},"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src/can"),"\nand\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src/motor"},"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src/motor"),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src/laser"},"https://github.com/youseetoo/uc2-esp32/tree/betaBD/main/src/laser")),(0,r.kt)("h2",{id:"general-behaviour"},"General Behaviour"),(0,r.kt)("p",null,"When the ESP32 firmware boots, it immediately sends a stop command to each connected device (e.g., motors). Each motor halts and reports its current position back over the CAN bus, and this position is stored on the ESP32 for synchronization. Although CAN itself does not inherently define master or slave nodes, the ESP32 takes on a supervisory role by gathering updates from all auxiliary components and sending commands to them as needed. If a device, such as a joystick, triggers an update, the ESP32 recognizes it and reacts accordingly\u2014for instance, a PS4 controller connected via Bluetooth can signal the ESP32 to command the motors to move at a speed proportional to the joystick\u2019s position."),(0,r.kt)("h2",{id:"detailed-information"},"Detailed information"),(0,r.kt)("h3",{id:"1-file-structure-and-responsibilities"},(0,r.kt)("strong",{parentName:"h3"},"1. File Structure and Responsibilities")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"can_config.h"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Contains configuration constants and parameters for the CAN/TWAI interface (e.g., baud rates, pins, RX/TX queue sizes)."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"can_bus.h")," / ",(0,r.kt)("inlineCode",{parentName:"li"},"can_bus.cpp"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Handles low-level CAN/TWAI driver initialization on the ESP32."),(0,r.kt)("li",{parentName:"ul"},"Sets up the driver, assigns GPIO pins for RX/TX, configures filters, and starts the driver tasks."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"can_communication.h")," / ",(0,r.kt)("inlineCode",{parentName:"li"},"can_communication.cpp"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Implements the ISO-TP protocol layer on top of the raw CAN driver."),(0,r.kt)("li",{parentName:"ul"},"Provides functions to send/receive multi-frame messages."),(0,r.kt)("li",{parentName:"ul"},"Performs segmentation/reassembly of data larger than 8 bytes."),(0,r.kt)("li",{parentName:"ul"},"Dispatches received ISO-TP messages to the appropriate handling functions in other modules (e.g., motor, laser)."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"motor_control.h")," / ",(0,r.kt)("inlineCode",{parentName:"li"},"motor_control.cpp"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Defines commands and data structures for motor control."),(0,r.kt)("li",{parentName:"ul"},"Uses the CAN/ISO-TP interface to send motor commands and receive status/responses."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"laser_control.h")," / ",(0,r.kt)("inlineCode",{parentName:"li"},"laser_control.cpp"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Defines commands and data structures for laser control."),(0,r.kt)("li",{parentName:"ul"},"Uses the same CAN/ISO-TP interface to transmit commands (e.g., turn laser on/off, adjust power) and handle responses.")))),(0,r.kt)("h3",{id:"2-driver-initialization-can_buscpp"},(0,r.kt)("strong",{parentName:"h3"},"2. Driver Initialization (can_bus.cpp)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A function (e.g., ",(0,r.kt)("inlineCode",{parentName:"li"},"canBusInit()"),") initializes the ESP32 TWAI driver with parameters (baud rate, pins, mode)."),(0,r.kt)("li",{parentName:"ul"},"A TX queue and RX queue are created so that incoming CAN frames are posted to an internal task for processing."),(0,r.kt)("li",{parentName:"ul"},"The driver is started, placing the interface in active mode to send and receive frames.")),(0,r.kt)("h3",{id:"3-iso-tp-layer-can_communicationcpp"},(0,r.kt)("strong",{parentName:"h3"},"3. ISO-TP Layer (can_communication.cpp)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implements a standard ISO-TP segmentation and reassembly approach:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Single Frame (SF)")," for messages \u2264 7 bytes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"First Frame (FF)")," + ",(0,r.kt)("strong",{parentName:"li"},"Consecutive Frames (CF)")," for messages > 7 bytes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Flow Control (FC)")," frames to manage multi-frame flow and pacing."))),(0,r.kt)("li",{parentName:"ul"},"Data is wrapped in ISO-TP PDUs: the first nibble of the first byte indicates the frame type, and subsequent bytes indicate total payload length (for FF) or the consecutive frame index (for CF)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sendISOTPMessage()")," (naming may vary) takes a destination CAN ID, a pointer to the payload, and its length. It:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Splits the data into single or multi-frame segments."),(0,r.kt)("li",{parentName:"ul"},"Sends each segment with the correct ISO-TP header."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"onCanFrameReceived()")," (or similar) is invoked when the low-level driver passes a new frame:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Checks if it\u2019s a single frame or part of a multi-frame sequence."),(0,r.kt)("li",{parentName:"ul"},"Collects and reassembles data in a buffer if needed."),(0,r.kt)("li",{parentName:"ul"},"Once a complete message is reassembled, dispatches it to a higher-level handler via a function such as ",(0,r.kt)("inlineCode",{parentName:"li"},"processIsotpMessage(can_id, data, length)"),".")))),(0,r.kt)("h3",{id:"4-message-routing-and-handling"},(0,r.kt)("strong",{parentName:"h3"},"4. Message Routing and Handling")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Master \u2192 Motor"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Commands (e.g., set motor speed, move, stop, home) are packaged in a data buffer."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"motor_control.cpp")," calls a function in ",(0,r.kt)("inlineCode",{parentName:"li"},"can_communication.cpp")," to send the command using the motor\u2019s assigned CAN ID."),(0,r.kt)("li",{parentName:"ul"},"The motor firmware or slave node replies with a status or acknowledgment frame."),(0,r.kt)("li",{parentName:"ul"},"A callback in ",(0,r.kt)("inlineCode",{parentName:"li"},"motor_control.cpp")," interprets these replies (position reached, error states, etc.)."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Master \u2192 Laser"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Commands to enable/disable the laser, set power level, or check status are prepared similarly."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"laser_control.cpp")," calls the ISO-TP send function with the laser\u2019s assigned CAN ID."),(0,r.kt)("li",{parentName:"ul"},"Replies from the laser node are received and passed back to ",(0,r.kt)("inlineCode",{parentName:"li"},"laser_control.cpp")," for handling (e.g., reading actual power, temperature, error codes).")))),(0,r.kt)("h3",{id:"5-typical-flow"},(0,r.kt)("strong",{parentName:"h3"},"5. Typical Flow")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Initialization"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"canBusInit()")," starts the low-level driver."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"initCanCommunication()")," (if present) sets up internal buffers/tables for ISO-TP."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Sending a Command"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The motor or laser module constructs a payload (command + parameters)."),(0,r.kt)("li",{parentName:"ul"},"Calls ",(0,r.kt)("inlineCode",{parentName:"li"},"sendISOTPMessage(motor_can_id, payload, length)")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"sendISOTPMessage(laser_can_id, payload, length)"),"."),(0,r.kt)("li",{parentName:"ul"},"The ISO-TP layer segments the data if necessary and transmits."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Receiving a Response"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The low-level driver receives each CAN frame in the RX queue."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"onCanFrameReceived()")," reassembles multi-frame messages (if needed)."),(0,r.kt)("li",{parentName:"ul"},"Once reassembly completes, ",(0,r.kt)("inlineCode",{parentName:"li"},"processIsotpMessage()")," routes the final data to the correct higher-level function: ",(0,r.kt)("inlineCode",{parentName:"li"},"handleMotorMessage()")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"handleLaserMessage()"),"."),(0,r.kt)("li",{parentName:"ul"},"The motor/laser modules parse the data and update internal state or trigger further actions.")))),(0,r.kt)("h3",{id:"6-configuration-parameters-can_configh"},(0,r.kt)("strong",{parentName:"h3"},"6. Configuration Parameters (can_config.h)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Definitions for baud rate (e.g., 250 kbit/s or 500 kbit/s)."),(0,r.kt)("li",{parentName:"ul"},"Pins for TX and RX (commonly GPIO4 for RX and GPIO5 for TX on ESP32, but can vary)."),(0,r.kt)("li",{parentName:"ul"},"ISO-TP protocol constants like timeouts, flow control behavior, and max buffer size.")),(0,r.kt)("h3",{id:"7-masterslave-can-ids"},(0,r.kt)("strong",{parentName:"h3"},"7. Master/Slave CAN IDs")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The firmware typically assigns unique CAN IDs to each slave (motor, laser, etc.)."),(0,r.kt)("li",{parentName:"ul"},"The master uses another ID or set of IDs for transmission and expects responses from the matching IDs."),(0,r.kt)("li",{parentName:"ul"},"The exact numeric IDs can be found in ",(0,r.kt)("inlineCode",{parentName:"li"},"can_config.h")," or within the motor/laser modules.")),(0,r.kt)("h3",{id:"8-extending-commands"},(0,r.kt)("strong",{parentName:"h3"},"8. Extending Commands")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"New commands can be defined by expanding the enumerations or definitions in ",(0,r.kt)("inlineCode",{parentName:"li"},"motor_control.h")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"laser_control.h"),"."),(0,r.kt)("li",{parentName:"ul"},"Corresponding parsing logic (in the receive callback for each device) must handle the new command codes.")),(0,r.kt)("h3",{id:"9-error-handling"},(0,r.kt)("strong",{parentName:"h3"},"9. Error Handling")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ISO-TP layer checks for missing frames and timeouts."),(0,r.kt)("li",{parentName:"ul"},"If frames are not received in a defined timeout window, the reassembly is aborted."),(0,r.kt)("li",{parentName:"ul"},"Callbacks or error codes can be sent back to the motor or laser modules to indicate incomplete transfers or bus errors.")),(0,r.kt)("h3",{id:"10-summary-of-key-points"},(0,r.kt)("strong",{parentName:"h3"},"10. Summary of Key Points")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"can_bus.*")," sets up and runs the low-level CAN/TWAI driver."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"can_communication.*")," manages ISO-TP (splitting/joining multi-frame data)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"motor_control.*")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"laser_control.*")," define higher-level commands sent over ISO-TP."),(0,r.kt)("li",{parentName:"ul"},"Incoming frames are routed to the relevant device module once reassembled.")),(0,r.kt)("p",null,"All higher-level device control (motor and laser) flows through the ISO-TP layer provided in ",(0,r.kt)("inlineCode",{parentName:"p"},"can_communication.cpp"),", ensuring that large payloads or complex commands are split and reassembled according to the ISO-TP standard."))}p.isMDXComponent=!0}}]);