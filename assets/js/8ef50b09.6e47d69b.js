"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[7974],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=a.createContext({}),p=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(r.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,h=u["".concat(r,".").concat(d)]||u[d]||m[d]||s;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,o=new Array(s);o[0]=u;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},21963:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const s={id:"DPCmicroscopy",title:"Differential Phase Contrast Microscopy"},o="Differential Phase Contrast",l={unversionedId:"Toolboxes/DiscoveryPhaseMicroscopy/DPCmicroscopy",id:"Toolboxes/DiscoveryPhaseMicroscopy/DPCmicroscopy",title:"Differential Phase Contrast Microscopy",description:"Differential Phase Contrast Microscopy is a Computational Microscopy technique that uses partial coherent sources to illuminate a sample at various angles (oblique illumination). The angle determines the illumination NA which contributes to the final resolution. Throughout this tutorial we are going to revise the theory and implementation of DPC using OpenUC2! The tutorial will explain how to build your own DPC setup and we provide with the reconstruction algorithm given the physical parameters (based on Waller's Lab reconstruction algorithm).",source:"@site/docs/01_Toolboxes/07_DiscoveryPhaseMicroscopy/DPC.md",sourceDirName:"01_Toolboxes/07_DiscoveryPhaseMicroscopy",slug:"/Toolboxes/DiscoveryPhaseMicroscopy/DPCmicroscopy",permalink:"/docs/Toolboxes/DiscoveryPhaseMicroscopy/DPCmicroscopy",draft:!1,tags:[],version:"current",frontMatter:{id:"DPCmicroscopy",title:"Differential Phase Contrast Microscopy"},sidebar:"tutorialSidebar",previous:{title:"Phase Microscopy",permalink:"/docs/Toolboxes/DiscoveryPhaseMicroscopy/"},next:{title:"openUC2 LASER Fluoresence microscope",permalink:"/docs/Toolboxes/DiscoveryFluorescenceLASER/LASER_Fluoresence_microscope"}},r={},p=[{value:"Weak Object Transfer Function",id:"weak-object-transfer-function",level:2},{value:"Condenser lens",id:"condenser-lens",level:2},{value:"Tutorial: DPC setup",id:"tutorial-dpc-setup",level:2},{value:"Materials needed:",id:"materials-needed",level:3},{value:"Diagram:",id:"diagram",level:3},{value:"Instructions for assembling the DPC setup:",id:"instructions-for-assembling-the-dpc-setup",level:3},{value:"DPC Images",id:"dpc-images",level:2},{value:"Reconstruction algorithm (Waller-Lab)",id:"reconstruction-algorithm-waller-lab",level:2},{value:"Initialize DPC Solver",id:"initialize-dpc-solver",level:2},{value:"Visualize Source Patterns",id:"visualize-source-patterns",level:2},{value:"Visualize Weak Object Transfer Functions",id:"visualize-weak-object-transfer-functions",level:2},{value:"Solve DPC Least Squares Problem",id:"solve-dpc-least-squares-problem",level:2}],c={toc:p};function m(e){let{components:t,...s}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"differential-phase-contrast"},"Differential Phase Contrast"),(0,i.kt)("p",null,"Differential Phase Contrast Microscopy is a Computational Microscopy technique that uses partial coherent sources to illuminate a sample at various angles (oblique illumination). The angle determines the illumination NA which contributes to the final resolution. Throughout this tutorial we are going to revise the theory and implementation of DPC using OpenUC2! The tutorial will explain how to build your own DPC setup and we provide with the reconstruction algorithm given the physical parameters (based on Waller's Lab reconstruction algorithm)."),(0,i.kt)("h2",{id:"weak-object-transfer-function"},"Weak Object Transfer Function"),(0,i.kt)("h2",{id:"condenser-lens"},"Condenser lens"),(0,i.kt)("h2",{id:"tutorial-dpc-setup"},"Tutorial: DPC setup"),(0,i.kt)("h3",{id:"materials-needed"},"Materials needed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"LED array (4x4)"),(0,i.kt)("li",{parentName:"ul"},"Hikrobot Camera (MV-CE060-10UC) with USB cable (",(0,i.kt)("a",{parentName:"li",href:"Camera_Software_tutorial.md"},"Hikrobot Camera Software installation"),")"),(0,i.kt)("li",{parentName:"ul"},"ESP32 Module"),(0,i.kt)("li",{parentName:"ul"},"XYZ sample mount stage"),(0,i.kt)("li",{parentName:"ul"},"Microscope Objective (0.25 ",(0,i.kt)("em",{parentName:"li"},"NA")," x10 )"),(0,i.kt)("li",{parentName:"ul"},"Motorized Linear stage"),(0,i.kt)("li",{parentName:"ul"},"Non-Kinematic Mirror"),(0,i.kt)("li",{parentName:"ul"},"Positive lens with 50 mm focal length"),(0,i.kt)("li",{parentName:"ul"},"Five empty cubes"),(0,i.kt)("li",{parentName:"ul"},"15 base plates"),(0,i.kt)("li",{parentName:"ul"},"Tube lens (with camera adapter)")),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(24473).Z,width:"967",height:"735"})),(0,i.kt)("h3",{id:"diagram"},"Diagram:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(17216).Z,width:"1041",height:"843"})),(0,i.kt)("h3",{id:"instructions-for-assembling-the-dpc-setup"},"Instructions for assembling the DPC setup:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Step 1: Download Imswitch and the ESP32 microcontroller drivers")),(0,i.kt)("p",null,"Once the drivers are installed you can visit (",(0,i.kt)("a",{parentName:"p",href:"https://youseetoo.github.io/indexWebSerialTest.html"},"youseetoo.github.io"),") to test the LED array pattern sequences."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(89587).Z,width:"537",height:"390"}),(0,i.kt)("img",{src:n(10736).Z,width:"520",height:"646"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Step 2: Mount the LED array")),(0,i.kt)("p",null,"Mount the LED array into the LED array base plate and insert it in a cube as shown."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(76217).Z,width:"2328",height:"1599"}),"\n",(0,i.kt)("img",{src:n(33428).Z,width:"4624",height:"2080"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Step 3: Build the DPC setup")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Substep 1")),(0,i.kt)("p",null,"Build the camera module as shown. It comprises of a tube lens and a Hikrobot Camera. Adjust the screw which binds the camera to the camera base plate to get the right distance between the camera and the tube lens.\n",(0,i.kt)("img",{src:n(99211).Z,width:"4624",height:"2080"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Substep 2")),(0,i.kt)("p",null,"Insert the non-kinematic mirror, the microscope objective in the fixed mount and the XYZ stage accordingly.\n",(0,i.kt)("img",{src:n(38427).Z,width:"4624",height:"2080"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Substep 3")),(0,i.kt)("p",null,"Build the illumination module which comprises of the LED array and the condenser lens as shown."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(35099).Z,width:"301",height:"270"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Substep 4")),(0,i.kt)("p",null,"Finally, on top of the module built in substep 2 add the illimination module."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(89175).Z,width:"243",height:"362"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Step 4: Adjust the Source-sample distance")),(0,i.kt)("p",null,"First, adjust the distance between the LED array and the condenser lens by placing them a focal distance (",(0,i.kt)("em",{parentName:"p"},"f")," = 50 mm) apart. This assures the plane wave illumination. Then, adjust the XYZ to the central positions. Adjust the Microscope objective position so that it matches roughly the working distance."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Step 5: Focus on the sample")),(0,i.kt)("p",null," Use Imswitch to turn one of the central LEDs, place a test sample to focus on it by coarse moving the microscope objective and finely tuning the height using the XYZ stage. Once it is in focus, adjust the distance from the condenser to the sample to be the focal length (",(0,i.kt)("em",{parentName:"p"},"f")," = 50 mm).  In this geometry the LED array dimensions are near the match illumination condition. Hence, some LEDs illuminate at the objective ",(0,i.kt)("em",{parentName:"p"},"NA")," (",(0,i.kt)("em",{parentName:"p"},"NAi")," = ",(0,i.kt)("em",{parentName:"p"},"NAobj"),")."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note:")," If your sample is transparent be careful not to crash the sample with the microscope objective! For more information about this experimental setup look at: ",(0,i.kt)("a",{parentName:"p",href:"http://dx.doi.org/10.1364/OL.39.001326"},"3D differential phase-contrast microscopy with computational illumination using an LED array"),"."),(0,i.kt)("p",null,"Example of illuminating sample with one half circle illumination. We should be able to see the phase gradient using oblique illumination. In the figure we can compare a defocused and focused image of a cheek cells sample."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(70307).Z,width:"1790",height:"803"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Step 6: Run the ImDPC experiment!")),(0,i.kt)("p",null,"Once you have focused on the sample, adjust the desired FoV. Now you are set. Click ",(0,i.kt)("em",{parentName:"p"},"Start")," on the DPC widget!"),(0,i.kt)("p",null,"Congrats! You have created a DPC microscope with OpenUC2!"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(98881).Z,width:"395",height:"768"})),(0,i.kt)("h2",{id:"dpc-images"},"DPC Images"),(0,i.kt)("p",null,"Using the reconstruction algorithm we can retrieve the phase of the sample."),(0,i.kt)("p",null,"First test with the OpenUC2-DPC setup:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(43273).Z,width:"1024",height:"683"})),(0,i.kt)("p",null,"In the animation you can compare the contrast that we can get with brightfield illumination and the DPC reconstruction generated by the four images taken with the half circle illumination."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(16790).Z,width:"630",height:"426"}),(0,i.kt)("img",{src:n(29552).Z,width:"451",height:"451"})),(0,i.kt)("p",null,"Taking a series of DPC images at different focal planes. Cropped DPC image of Unknown cells (top) and Cheek cells (bottom) captured with 0.25 NA microscope objective with 10x magnification."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(43596).Z,width:"370",height:"372"})),(0,i.kt)("p",null,"Left:Cropped DPC image captured with 0.17 NA microscope objective with 4x magnification."),(0,i.kt)("h2",{id:"reconstruction-algorithm-waller-lab"},"Reconstruction algorithm (Waller-Lab)"),(0,i.kt)("p",null,"The reconstruction algorithm works with the development of the Weak Object Transfer Function (WOTF). Using the code implemented by Waller (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Waller-Lab/DPC"},"Waller-Lab/DPC"),"), we are able to reconstruct the absorption and phase of the samples. Here we explain each step and implementation of the code using Imswitch."),(0,i.kt)("p",null,"We are going to revise each part of the code and understand it."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Acquisition")),(0,i.kt)("p",null,"We need four images corresponding to each half-circle illumination pattern. With a good exposure time for the camera to reduce noise. In the figure we can see an example of the four captured DPC images."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(1323).Z,width:"2131",height:"2158"})),(0,i.kt)("p",null,"We can correct the images using flatfield correction. Flatfield correction consists on taking an image without the sample, then we take the image to be corrected and divided by the flatfield image. This enables us to get rid of noise like dust on the camera, for instance."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The code")),(0,i.kt)("p",null,"The code consist of a Jupyter notebook and one python script."),(0,i.kt)("p",null,"Python script: dpc_algorithm.py"),(0,i.kt)("p",null,"This script contains the core algorithm to solve the DPC problem and from the four acquired images retrieve the phase."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"import numpy as np\nfrom scipy.ndimage import uniform_filter\npi    = np.pi\nnaxis = np.newaxis\nF     = lambda x: np.fft.fft2(x)\nIF    = lambda x: np.fft.ifft2(x)\n\ndef pupilGen(fxlin, fylin, wavelength, na, na_in=0.0):\n    pupil = np.array(fxlin[naxis, :]**2+fylin[:, naxis]**2 <= (na/wavelength)**2)\n    if na_in != 0.0:\n        pupil[fxlin[naxis, :]**2+fylin[:, naxis]**2 < (na_in/wavelength)**2] = 0.0\n    return pupil\n\ndef _genGrid(size, dx):\n    xlin = np.arange(size, dtype='complex128')\n    return (xlin-size//2)*dx\n\nclass DPCSolver:\n    def __init__(self, dpc_imgs, wavelength, na, na_in, pixel_size, rotation, dpc_num=4):\n        self.wavelength = wavelength\n        self.na         = na\n        self.na_in      = na_in\n        self.pixel_size = pixel_size\n        self.dpc_num    = 4\n        self.rotation   = rotation\n        self.fxlin      = np.fft.ifftshift(_genGrid(dpc_imgs.shape[-1], 1.0/dpc_imgs.shape[-1]/self.pixel_size))\n        self.fylin      = np.fft.ifftshift(_genGrid(dpc_imgs.shape[-2], 1.0/dpc_imgs.shape[-2]/self.pixel_size))\n        self.dpc_imgs   = dpc_imgs.astype('float64')\n        self.normalization()\n        self.pupil      = pupilGen(self.fxlin, self.fylin, self.wavelength, self.na)\n        self.sourceGen()\n        self.WOTFGen()\n\n    def setTikhonovRegularization(self, reg_u = 1e-6, reg_p = 1e-6):\n        self.reg_u      = reg_u\n        self.reg_p      = reg_p\n\n    def normalization(self):\n        for img in self.dpc_imgs:\n            img          /= uniform_filter(img, size=img.shape[0]//2)\n            meanIntensity = img.mean()\n            img          /= meanIntensity        # normalize intensity with DC term\n            img          -= 1.0                  # subtract the DC term\n\n    def sourceGen(self):\n        self.source = []\n        pupil       = pupilGen(self.fxlin, self.fylin, self.wavelength, self.na, na_in=self.na_in)\n        for rotIdx in range(self.dpc_num):\n            self.source.append(np.zeros((self.dpc_imgs.shape[-2:])))\n            rotdegree = self.rotation[rotIdx]\n            if rotdegree < 180:\n                self.source[-1][self.fylin[:, naxis]*np.cos(np.deg2rad(rotdegree))+1e-15>=\n                                self.fxlin[naxis, :]*np.sin(np.deg2rad(rotdegree))] = 1.0\n                self.source[-1] *= pupil\n            else:\n                self.source[-1][self.fylin[:, naxis]*np.cos(np.deg2rad(rotdegree))+1e-15<\n                                self.fxlin[naxis, :]*np.sin(np.deg2rad(rotdegree))] = -1.0\n                self.source[-1] *= pupil\n                self.source[-1] += pupil\n        self.source = np.asarray(self.source)\n\n    def WOTFGen(self):\n        self.Hu = []\n        self.Hp = []\n        for rotIdx in range(self.source.shape[0]):\n            FSP_cFP  = F(self.source[rotIdx]*self.pupil)*F(self.pupil).conj()\n            I0       = (self.source[rotIdx]*self.pupil*self.pupil.conj()).sum()\n            self.Hu.append(2.0*IF(FSP_cFP.real)/I0)\n            self.Hp.append(2.0j*IF(1j*FSP_cFP.imag)/I0)\n        self.Hu = np.asarray(self.Hu)\n        self.Hp = np.asarray(self.Hp)\n\n    def solve(self, xini=None, plot_verbose=False, **kwargs):\n        dpc_result  = []\n        AHA         = [(self.Hu.conj()*self.Hu).sum(axis=0)+self.reg_u,            (self.Hu.conj()*self.Hp).sum(axis=0),\\\n                       (self.Hp.conj()*self.Hu).sum(axis=0)           , (self.Hp.conj()*self.Hp).sum(axis=0)+self.reg_p]\n        determinant = AHA[0]*AHA[3]-AHA[1]*AHA[2]\n        for frame_index in range(self.dpc_imgs.shape[0]//self.dpc_num):\n            fIntensity = np.asarray([F(self.dpc_imgs[frame_index*self.dpc_num+image_index]) for image_index in range(self.dpc_num)])\n            AHy        = np.asarray([(self.Hu.conj()*fIntensity).sum(axis=0), (self.Hp.conj()*fIntensity).sum(axis=0)])\n            absorption = IF((AHA[3]*AHy[0]-AHA[1]*AHy[1])/determinant).real\n            phase      = IF((AHA[0]*AHy[1]-AHA[2]*AHy[0])/determinant).real\n            dpc_result.append(absorption+1.0j*phase)\n\n        return np.asarray(dpc_result)\n")),(0,i.kt)("p",null,"Jupyer notebook: main_dpc.ipynb"),(0,i.kt)("p",null,"With this Jupyter notebook you can test the DPC reconstruction algorithm using your own images!"),(0,i.kt)("h1",{id:"import-modules"},"Import Modules"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"%load_ext autoreload\n%autoreload 2\n%matplotlib notebook\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom os import listdir\nfrom skimage import io\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom dpc_algorithm import DPCSolver\n")),(0,i.kt)("h1",{id:"load-dpc-measurements"},"Load DPC Measurements"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'data_path  = "../sample_data/" #INSERT YOUR DATA PATH HERE\nimage_list = listdir(data_path)\nimage_list = [image_file for image_file in image_list if image_file.endswith(".tif")]\nimage_list.sort()\ndpc_images = np.array([io.imread(data_path+image_list[image_index]) for image_index in range(len(image_list))])\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#plot first set of measured DPC measurements\nf, ax = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 6))\n\nfor plot_index in range(4):\n    plot_row = plot_index//2\n    plot_col = np.mod(plot_index, 2)\n    ax[plot_row, plot_col].imshow(dpc_images[plot_index], cmap="gray",\\\n                                  extent=[0, dpc_images[0].shape[-1], 0, dpc_images[0].shape[-2]])\n    ax[plot_row, plot_col].axis("off")\n    ax[plot_row, plot_col].set_title("DPC {:02d}".format(plot_index))\n    plt.show()\n')),(0,i.kt)("p",null,"Output (example):"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(7128).Z,width:"483",height:"502"})),(0,i.kt)("h1",{id:"set-system-parameters"},"Set System Parameters"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"wavelength     =  0.514 #micron\nmag            =   40.0\nna             =   0.40 #numerical aperture\nna_in          =    0.0\npixel_size_cam =    6.5 #pixel size of camera\ndpc_num        =      4 #number of DPC images captured for each absorption and phase frame\npixel_size     = pixel_size_cam/mag\nrotation       = [0, 180, 90, 270] #degree\n")),(0,i.kt)("h1",{id:"dpc-absorption-and-phase-retrieval"},"DPC Absorption and Phase Retrieval"),(0,i.kt)("h2",{id:"initialize-dpc-solver"},"Initialize DPC Solver"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"dpc_solver_obj = DPCSolver(dpc_images, wavelength, na, na_in, pixel_size, rotation, dpc_num=dpc_num)\n")),(0,i.kt)("h2",{id:"visualize-source-patterns"},"Visualize Source Patterns"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#plot the sources\nmax_na_x = max(dpc_solver_obj.fxlin.real*dpc_solver_obj.wavelength/dpc_solver_obj.na)\nmin_na_x = min(dpc_solver_obj.fxlin.real*dpc_solver_obj.wavelength/dpc_solver_obj.na)\nmax_na_y = max(dpc_solver_obj.fylin.real*dpc_solver_obj.wavelength/dpc_solver_obj.na)\nmin_na_y = min(dpc_solver_obj.fylin.real*dpc_solver_obj.wavelength/dpc_solver_obj.na)\nf, ax  = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 6))\nfor plot_index, source in enumerate(list(dpc_solver_obj.source)):\n    plot_row = plot_index//2\n    plot_col = np.mod(plot_index, 2)\n    ax[plot_row, plot_col].imshow(np.fft.fftshift(dpc_solver_obj.source[plot_index]),\\\n                                  cmap=\'gray\', clim=(0,1), extent=[min_na_x, max_na_x, min_na_y, max_na_y])\n    ax[plot_row, plot_col].axis("off")\n    ax[plot_row, plot_col].set_title("DPC Source {:02d}".format(plot_index))\n    ax[plot_row, plot_col].set_xlim(-1.2, 1.2)\n    ax[plot_row, plot_col].set_ylim(-1.2, 1.2)\n    ax[plot_row, plot_col].set_aspect(1)\n')),(0,i.kt)("p",null,"Output (example):"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(64838).Z,width:"483",height:"502"})),(0,i.kt)("h2",{id:"visualize-weak-object-transfer-functions"},"Visualize Weak Object Transfer Functions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#plot the transfer functions\nf, ax = plt.subplots(2, 4, sharex=True, sharey=True, figsize = (10, 4))\nfor plot_index in range(ax.size):\n    plot_row = plot_index//4\n    plot_col = np.mod(plot_index, 4)\n    divider  = make_axes_locatable(ax[plot_row, plot_col])\n    cax      = divider.append_axes("right", size="5%", pad=0.05)\n    if plot_row == 0:\n        plot = ax[plot_row, plot_col].imshow(np.fft.fftshift(dpc_solver_obj.Hu[plot_col].real), cmap=\'jet\',\\\n                                             extent=[min_na_x, max_na_x, min_na_y, max_na_y], clim=[-2., 2.])\n        ax[plot_row, plot_col].set_title("Absorption WOTF {:02d}".format(plot_col))\n        plt.colorbar(plot, cax=cax, ticks=[-2., 0, 2.])\n    else:\n        plot = ax[plot_row, plot_col].imshow(np.fft.fftshift(dpc_solver_obj.Hp[plot_col].imag), cmap=\'jet\',\\\n                                             extent=[min_na_x, max_na_x, min_na_y, max_na_y], clim=[-.8, .8])\n        ax[plot_row, plot_col].set_title("Phase WOTF {:02d}".format(plot_col))\n        plt.colorbar(plot, cax=cax, ticks=[-.8, 0, .8])\n    ax[plot_row, plot_col].set_xlim(-2.2, 2.2)\n    ax[plot_row, plot_col].set_ylim(-2.2, 2.2)\n    ax[plot_row, plot_col].axis("off")\n    ax[plot_row, plot_col].set_aspect(1)\n')),(0,i.kt)("p",null,"Output (example):"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(99115).Z,width:"837",height:"356"})),(0,i.kt)("h2",{id:"solve-dpc-least-squares-problem"},"Solve DPC Least Squares Problem"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#parameters for Tikhonov regurlarization [absorption, phase] ((need to tune this based on SNR)\ndpc_solver_obj.setTikhonovRegularization(reg_u = 1e-1, reg_p = 5e-3)\ndpc_result = dpc_solver_obj.solve()\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'_, axes  = plt.subplots(1, 2, figsize=(10, 6), sharex=True, sharey=True)\ndivider  = make_axes_locatable(axes[0])\ncax_1    = divider.append_axes("right", size="5%", pad=0.05)\nplot     = axes[0].imshow(dpc_result[0].real, clim=[-0.15, 0.02], cmap="gray", extent=[0, dpc_result[0].shape[-1], 0, dpc_result[0].shape[-2]])\naxes[0].axis("off")\nplt.colorbar(plot, cax=cax_1, ticks=[-0.15, 0.02])\naxes[0].set_title("Absorption")\ndivider  = make_axes_locatable(axes[1])\ncax_2    = divider.append_axes("right", size="5%", pad=0.05)\nplot     = axes[1].imshow(dpc_result[0].imag, clim=[-1.0, 3.0], cmap="gray", extent=[0, dpc_result[0].shape[-1], 0, dpc_result[0].shape[-2]])\naxes[1].axis("off")\nplt.colorbar(plot, cax=cax_2, ticks=[-1.0, 3.0])\naxes[1].set_title("Phase")\n')),(0,i.kt)("p",null,"Output (example):"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(9739).Z,width:"838",height:"379"})))}m.isMDXComponent=!0},43273:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Brightfield_test_cells_10x0.25-ANIMATION-92cccaf47327715121a33871022ec14a.gif"},99211:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Camera_module-384182d0a773d147d35bacbe719701a7.jpg"},70307:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Cheek_cells_focused_DPC-726d9df02363b0a9dd9f42cd8e70f7a5.png"},29552:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Cheek_defocused_DPC-432d40c271ddb3c60284bc7df70923c6.gif"},17216:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/DPC_diagram-de66d9045c4997b75d7ca6f150ceb52c.png"},98881:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/DPC_final_setup-41383e2a12d7baa6a18a36523f74ceb1.png"},7128:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/DPC_measurements-2d63d61330968a716057c90748e8bb48.png"},24473:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/DPC_setup-bff29f5c4f674cafddd27528e3456a57.png"},38427:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/DPC_setup_step_1-dd19b20c4dfe621ff912a600eed6b0de.jpg"},35099:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/DPC_setup_step_2-dbd8a20038269b6091f86fbf978a8fb6.jpg"},89175:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/DPC_setup_step_3-260d85eb48af6825761f4251fa62b2d7.jpg"},89587:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/ESP32-c93f50cf670a233513c5a56d1abc4d23.png"},33428:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/LED_array_insert-1d65ae3ddad6beed680213d1709734d6.jpg"},10736:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/LED_array_patterns-c3416a7dee494c9f31430b77a7b7cdac.gif"},76217:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/LED_base-d91956214ccc22e4b5e89b50bd125d29.png"},9739:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Reconstruction_example-e38dfd238ee793632c802a6a793b5944.png"},64838:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Source_patterns-cdff4bc6635777e22d1b647319bf8b33.png"},1323:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Top_bottom_right_left-ef4659ef4e876780231f80370ad6f424.png"},99115:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/WOTFs-f221f00e89336779f663e0330b35c6ed.png"},43596:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dpc_4x_0.17NA-56e64c4946c48ceab6266196d8e9ea14.gif"},16790:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/focusing_dpc_animation-395150b9ee89814e897fd3baf4aca867.gif"}}]);