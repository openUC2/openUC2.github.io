"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[7768],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||a;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},80641:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const a={id:"uc2e5.2",title:"Python commands"},o=void 0,l={unversionedId:"Electronics/uc2e5.2",id:"Electronics/uc2e5.2",title:"Python commands",description:"Using UC2-REST in Python",source:"@site/docs/03_Electronics/051_Sending_Commands_via_Python.md",sourceDirName:"03_Electronics",slug:"/Electronics/uc2e5.2",permalink:"/docs/Electronics/uc2e5.2",draft:!1,tags:[],version:"current",sidebarPosition:51,frontMatter:{id:"uc2e5.2",title:"Python commands"},sidebar:"tutorialSidebar",previous:{title:"CANInterface",permalink:"/docs/Electronics/CANInterface"},next:{title:"HIK-Camera Software Installation",permalink:"/docs/Electronics/HIKCamera/SoftwareTutorial"}},s={},c=[{value:"Using UC2-REST in Python",id:"using-uc2-rest-in-python",level:2},{value:"Initialize the Library",id:"initialize-the-library",level:3},{value:"Manual Command Sending",id:"manual-command-sending",level:3}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"using-uc2-rest-in-python"},"Using UC2-REST in Python"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"uc2rest")," library communicates with an ESP32 microcontroller via a serial connection and is available here ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openUC2/UC2-REST/"},"https://github.com/openUC2/UC2-REST/")," and via ",(0,i.kt)("inlineCode",{parentName:"p"},"pip install uc2-rest"),"."),(0,i.kt)("p",null,"The script below starts by importing the necessary modules, including ",(0,i.kt)("inlineCode",{parentName:"p"},"uc2rest"),", which provides a high-level interface for communicating with the ESP32 using the UC2 protocol. Next, the script initializes the ",(0,i.kt)("inlineCode",{parentName:"p"},"UC2Client")," object with a serial port and enables debug output for the serial connection."),(0,i.kt)("p",null,"After verifying that the correct device is connected, the script sends a test command to the ESP32 to retrieve the current state of the motor using the ",(0,i.kt)("inlineCode",{parentName:"p"},"motor_get")," task. The returned data is printed to the console."),(0,i.kt)("p",null,"Note that the command is formatted as a string in JSON format, using single quotes instead of double quotes. This is because the JSON format requires double quotes, but Python interprets double quotes as the beginning or end of a string, which can cause issues when sending commands over a serial connection."),(0,i.kt)("h3",{id:"initialize-the-library"},"Initialize the Library"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},'# Import necessary libraries\nimport uc2rest\nimport numpy as np\nimport time\n\n# Define serial port\nport = "unknown"\n\n# Create UC2Client object with specified serial port and debug settings\nESP32 = uc2rest.UC2Client(serialport=port, DEBUG=True)\nESP32.serial.DEBUG=True # Setting debug output of the serial to true - all messages will be printed\n\n# Check if device is connected and confirm it is the right one\nmState = ESP32.state.get_state()\n')),(0,i.kt)("h3",{id:"manual-command-sending"},"Manual Command Sending"),(0,i.kt)("p",null,"Send a command you formulate manually"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"''' ################\nSERIAL\n################'''\n\n# Define a test command to send to the UC2 device via serial\ntest_cmd = \"{'task': '/motor_get'}\"\n\n# Send the test command to the UC2 device via serial\nESP32.serial.writeSerial(test_cmd)\n")),(0,i.kt)("p",null,"The below code can be used to manipulate the LED."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"''' ################\nLED\n################'''\n\n# Create an instance of the ESP32 class\nESP32 = ESP32()\n\n# Turn on all LEDs with full white color (RGB)\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(255, 255, 255))\ntime.sleep(0.5)  # Pause for half a second\n\n# Turn off all LEDs\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(0, 0, 0))\n\n# Turn on each LED one by one with full white color (RGB) and turn it off immediately\nfor iLED in range(5):\n    # Turn on a single LED by index number\n    mResult = ESP32.led.send_LEDMatrix_single(indexled=iLED, intensity=(255, 255, 255), timeout=0.)\n    # Turn off the same LED\n    mResult = ESP32.led.send_LEDMatrix_single(indexled=iLED, intensity=(0, 0, 0), timeout=0.)\n\n# Display a random pattern on the LED matrix for 5 times\nfor i in range(5):\n    # Generate a random pattern of 25 LEDs with 3 color values (RGB)\n    led_pattern = np.random.randint(0, 55, (25, 3))\n    # Display the pattern on the LED matrix\n    mResult = ESP32.led.send_LEDMatrix_array(led_pattern=led_pattern, timeout=0)\n    # Check if the pattern was sent successfully\n    assert mResult[\"success\"] == 1, \"Failed sending LED command\"\n\n# Display a left-to-right moving pattern on the LED matrix (commented out with if statement)\nif(0):\n    # Create an empty LED pattern\n    led_pattern = np.zeros((25, 3))\n    # Define the left and right halves of the LED matrix by index numbers\n    list_left = (0, 1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14, 15, 16, 17)\n    list_right = (0, 5, 6, 7, 8, 9, 18, 19, 20, 21, 22, 23, 24)\n    # Turn on the left half of the LED pattern to full red (RGB = (255, 0, 0))\n    led_pattern[list_left, 0] = 255\n    # Turn on the right half of the LED pattern to full green (RGB = (0, 255, 0))\n    led_pattern[list_right, 1] = 255\n    # Display the pattern on the LED matrix for 1 second\n    ESP32.led.send_LEDMatrix_array(led_pattern=led_pattern, timeout=1)\n    # Turn off the LED matrix\n    ESP32.led.send_LEDMatrix_array(led_pattern=led_pattern*0, timeout=1)\n")))}d.isMDXComponent=!0}}]);