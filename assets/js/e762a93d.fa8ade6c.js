"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[2103],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>u});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(t),u=i,g=d["".concat(l,".").concat(u)]||d[u]||c[u]||r;return t?a.createElement(g,o(o({ref:n},m),{},{components:t})):a.createElement(g,o({ref:n},m))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},27833:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const r={},o="UC2-REST: Python Interface for UC2-ESP32",s={unversionedId:"ImSwitch/Advanced/Usage/UC2-REST",id:"ImSwitch/Advanced/Usage/UC2-REST",title:"UC2-REST: Python Interface for UC2-ESP32",description:"UC2-REST is the Python interface library that enables communication between ImSwitch and the UC2-ESP32 firmware. It provides a unified API for controlling UC2 hardware components through both USB serial and WiFi connections.",source:"@site/docs/05_ImSwitch/Advanced/02_Usage/UC2-REST.md",sourceDirName:"05_ImSwitch/Advanced/02_Usage",slug:"/ImSwitch/Advanced/Usage/UC2-REST",permalink:"/docs/ImSwitch/Advanced/Usage/UC2-REST",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Micromanager Integration with ImSwitch",permalink:"/docs/ImSwitch/Advanced/Usage/Micromanager"},next:{title:"Updating ImSwitch and UC2 Components",permalink:"/docs/ImSwitch/Advanced/Usage/Updates"}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:3},{value:"Key Features",id:"key-features",level:2},{value:"Installation",id:"installation",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Connection",id:"basic-connection",level:3},{value:"Step-by-Step Tutorial",id:"step-by-step-tutorial",level:3},{value:"1. Installation and Setup",id:"1-installation-and-setup",level:4},{value:"2. Basic Connection Examples",id:"2-basic-connection-examples",level:4},{value:"3. Basic Hardware Control",id:"3-basic-hardware-control",level:4},{value:"4. Advanced Control Examples",id:"4-advanced-control-examples",level:4},{value:"Basic Commands",id:"basic-commands",level:3},{value:"Hardware Modules",id:"hardware-modules",level:2},{value:"Motor Control",id:"motor-control",level:3},{value:"LED Array Control",id:"led-array-control",level:3},{value:"Laser Control",id:"laser-control",level:3},{value:"Sensor Reading",id:"sensor-reading",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Configuration Management",id:"configuration-management",level:3},{value:"Custom Commands",id:"custom-commands",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Integration with ImSwitch",id:"integration-with-imswitch",level:2},{value:"Configuration in ImSwitch",id:"configuration-in-imswitch",level:3},{value:"ImSwitch Integration Examples",id:"imswitch-integration-examples",level:3},{value:"ESP32 Configuration Manager",id:"esp32-configuration-manager",level:4},{value:"Stage Manager Integration",id:"stage-manager-integration",level:4},{value:"LED Manager Integration",id:"led-manager-integration",level:4},{value:"Laser Manager Integration",id:"laser-manager-integration",level:4},{value:"Custom Device Manager Template",id:"custom-device-manager-template",level:4},{value:"Communication Protocols",id:"communication-protocols",level:2},{value:"USB Serial Protocol",id:"usb-serial-protocol",level:3},{value:"WiFi/HTTP Protocol",id:"wifihttp-protocol",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Connection Issues",id:"connection-issues",level:3},{value:"Command Debugging",id:"command-debugging",level:3},{value:"Common Error Solutions",id:"common-error-solutions",level:3},{value:"Examples and Scripts",id:"examples-and-scripts",level:2},{value:"Complete Setup Example",id:"complete-setup-example",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Related Resources",id:"related-resources",level:2}],m={toc:p};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"uc2-rest-python-interface-for-uc2-esp32"},"UC2-REST: Python Interface for UC2-ESP32"),(0,i.kt)("p",null,"UC2-REST is the Python interface library that enables communication between ImSwitch and the UC2-ESP32 firmware. It provides a unified API for controlling UC2 hardware components through both USB serial and WiFi connections."),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"UC2-REST serves as the bridge between:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ImSwitch"),": High-level microscopy control software"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"UC2-ESP32 Firmware"),": Low-level hardware control on ESP32 microcontrollers"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Hardware"),": Motors, LEDs, lasers, sensors, and other UC2 components")),(0,i.kt)("h3",{id:"architecture"},"Architecture"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ImSwitch \u2190\u2192 UC2-REST \u2190\u2192 [USB/WiFi] \u2190\u2192 UC2-ESP32 \u2190\u2192 Hardware\n")),(0,i.kt)("h2",{id:"key-features"},"Key Features"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Dual Communication"),": USB serial and WiFi/HTTP protocols"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"JSON API"),": Structured command and response format"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Modular Design"),": Support for different hardware modules"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Real-time Control"),": Low-latency hardware communication"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Error Handling"),": Robust error detection and recovery")),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)("p",null,"UC2-REST is automatically included with ImSwitch installations, but can also be installed separately:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Install from GitHub\ngit clone https://github.com/openUC2/UC2-REST\ncd UC2-REST\npip install -e .\n\n# Or install specific version (based on your version)\npip install UC2-REST==X.X.X\n")),(0,i.kt)("h2",{id:"quick-start"},"Quick Start"),(0,i.kt)("h3",{id:"basic-connection"},"Basic Connection"),(0,i.kt)("h3",{id:"step-by-step-tutorial"},"Step-by-Step Tutorial"),(0,i.kt)("h4",{id:"1-installation-and-setup"},"1. Installation and Setup"),(0,i.kt)("p",null,"First, ensure UC2-REST is installed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Install from GitHub\npip install git+https://github.com/openUC2/UC2-REST.git\n\n# Or install in development mode\ngit clone https://github.com/openUC2/UC2-REST\ncd UC2-REST\npip install -e .\n")),(0,i.kt)("h4",{id:"2-basic-connection-examples"},"2. Basic Connection Examples"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"USB Serial Connection (Recommended):")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from UC2REST import UC2Client\nimport time\n\n# Connect via USB\nport = "/dev/ttyUSB0"  # Linux\n# port = "COM3"        # Windows  \n# port = "/dev/cu.usbmodem101"  # macOS\n\nclient = UC2Client(serialport=port, baudrate=115200, DEBUG=True)\n\n# Check connection status\nif client.is_connected:\n    print("\u2713 Connected to UC2-ESP32")\n    print(f"Firmware version: {client.get_firmware_version()}")\nelse:\n    print("\u2717 Connection failed - check port and cable")\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"WiFi Connection (Experimental):")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Connect via WiFi (requires ESP32 in WiFi mode)\nclient = UC2Client(host="192.168.1.100", port=31950, DEBUG=True)\n\nif client.is_connected:\n    print("\u2713 Connected via WiFi")\nelse:\n    print("\u2717 WiFi connection failed")\n')),(0,i.kt)("h4",{id:"3-basic-hardware-control"},"3. Basic Hardware Control"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"LED Control:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Turn on LED\nclient.led.set_led(channel=1, value=100)  # Channel 1, 100% brightness\ntime.sleep(2)\n\n# Turn off LED\nclient.led.set_led(channel=1, value=0)\n\n# Control multiple LEDs\nclient.led.set_led_array([100, 50, 25, 0])  # Array of brightness values\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Motor Control:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Move stepper motor\nclient.motor.move_stepper(\n    stepperid=1,\n    position=1000,  # Steps\n    speed=15000,    # Steps/second\n    is_absolute=True\n)\n\n# Check motor status\nstatus = client.motor.get_position(stepperid=1)\nprint(f\"Motor position: {status['position']}\")\n\n# Home motor\nclient.motor.home_stepper(stepperid=1, timeout=20000)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Laser Control:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Turn on laser\nclient.laser.set_laser(channel=1, value=50)  # 50% power\ntime.sleep(1)\n\n# Turn off laser\nclient.laser.set_laser(channel=1, value=0)\n\n# Pulse laser\nclient.laser.pulse_laser(channel=1, value=100, duration=500)  # 500ms pulse\n")),(0,i.kt)("h4",{id:"4-advanced-control-examples"},"4. Advanced Control Examples"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Multi-Device Coordination:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Coordinate movement and illumination\ndef take_z_stack(client, z_positions, led_intensity=100):\n    images = []\n    \n    for z_pos in z_positions:\n        # Move to position\n        client.motor.move_stepper(stepperid=3, position=z_pos, speed=5000)\n        time.sleep(0.5)  # Wait for settling\n        \n        # Set illumination\n        client.led.set_led(channel=1, value=led_intensity)\n        time.sleep(0.1)  # Exposure time\n        \n        # Trigger camera (if connected)\n        # images.append(capture_image())\n        \n        # Turn off LED\n        client.led.set_led(channel=1, value=0)\n    \n    return images\n\n# Execute Z-stack\nz_positions = [0, 100, 200, 300, 400]  # Z positions in steps\ntake_z_stack(client, z_positions)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Error Handling:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'try:\n    # Attempt motor movement\n    client.motor.move_stepper(stepperid=1, position=5000, speed=10000)\n    \nexcept Exception as e:\n    print(f"Motor movement failed: {e}")\n    \n    # Check if motor is still connected\n    if not client.is_connected:\n        print("Connection lost - attempting to reconnect...")\n        client.reconnect()\n')),(0,i.kt)("h3",{id:"basic-commands"},"Basic Commands"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#%%\nimport uc2rest\nimport numpy as np\nimport time\n\nport = "unknown"\n#port = "/dev/cu.SLAB_USBtoUART"\n#port = "COM3"\nport = "/dev/cu.usbmodem101"\nprint("start")\nESP32 = uc2rest.UC2Client(serialport=port, baudrate=115200, DEBUG=True, skipFirmwareCheck=True)\n#ESP32.serial.sendMessage(\'{"task":"/home_act", "home": {"steppers": [{"stepperid":1, "timeout": 20000, "speed": 15000, "direction":1, "endposrelease":3000}]}}\')\n\n\n\n\'\'\' TEST LED \'\'\'\n\n# Create LedMatrix object, pass a reference to your \u201cparent\u201d that has post_json()\nmy_led_matrix = ESP32.led\n\nfor i in range(5):\n    # Turn off all LEDs\n    my_led_matrix.send_LEDMatrix_off()\n    time.sleep(0.1)\n    # Fill entire matrix with red\n    my_led_matrix.send_LEDMatrix_full((255,0,0))\n    time.sleep(0.1)\n# Light only left half in bright white\nmy_led_matrix.send_LEDMatrix_halves(region="left", intensity=(255,255,255))\n\n# Draw a ring of radius 3 in purple\nmy_led_matrix.send_LEDMatrix_rings(radius=3, intensity=(128,0,128))\n\n# Draw a filled circle of radius 5 in green\nmy_led_matrix.send_LEDMatrix_circles(radius=3, intensity=(0,255,0))\n\n\n\n\nfor iLED in range(5):\n    # timeout = 0 means no timeout => mResult will be rubish!\n    mResult = ESP32.led.send_LEDMatrix_single(indexled=iLED, intensity=(255, 255, 255), timeout=0.1)\n    mResult = ESP32.led.send_LEDMatrix_single(indexled=iLED, intensity=(0, 0, 0), timeout=0.1)\n\n# display random pattern\nfor i in range(5):\n    led_pattern = np.random.randint(0,55, (25,3))\n    mResult = ESP32.led.send_LEDMatrix_array(led_pattern=led_pattern,timeout=0)\n    assert mResult["success"] == 1, "Failed sending LED command"\n\n\n\n# {"task":"/ledarr_act", "led":{"LEDArrMode":1, "led_array":[{"id":0, "r":255, "g":255, "b":255}]}}\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(255, 255, 255))\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(0, 0, 0), getReturn=False)\n\n#\n\n\nESP32.home.home_x(speed =15000, direction = -1, endstoppolarity=1, timeout=10, isBlocking=True)\nESP32.home.home_y(speed =15000, direction = -1, endstoppolarity=-1, timeout=10, isBlocking=True)\nESP32.home.home_z(speed =15000, direction = 1, endstoppolarity=-1, timeout=10, isBlocking=True)\n\n\n# test the objective module\nESP32.objective.home(direction=-1, endstoppolarity=1, isBlocking=True)\n#ESP32.objective.calibrate(direction=-1, endstoppolarity=1, isBlocking=True)\n# set the homing positions \n\nfor i in range(2):\n    speed=25000\n    accel=40000\n    ESP32.objective.toggle(speed=speed, accel=accel, isBlocking=True)\n    ESP32.objective.toggle(speed=speed, accel=accel, isBlocking=True)\n\n# test servo \nif 0:\n    for i in range(180):\n        time.sleep(0.1)\n        ESP32.laser.set_servo(channel=1, value=0, is_blocking=False)    \n\n#%% TEMPERATURE\nif 0:\n    ESP32.temperature.start_temperature_polling()\n    time.sleep(5)\n    mTemperature = ESP32.temperature.get_temperature()\n    print(mTemperature)\n\n\n#%%\n\'\'\' ################\nHOME\n################\'\'\'\nif 1:\n    \'\'\'\n    for X=0\n    {"task":"/home_act","home":{"steppers":[{"stepperid":1,"timeout":20000,"speed":5000,"direction":-1,"endstoppolarity":1}]}}\n    for Y=0\n    {"task":"/home_act","home":{"steppers":[{"stepperid":2,"timeout":20000,"speed":15000,"direction":-1,"endstoppolarity":-1}]}}\n    for Z=0\n    {"task":"/home_act","home":{"steppers":[{"stepperid":3,"timeout":20000,"speed":15000,"direction":1,"endstoppolarity":-1}]}}\n    for A=0\n    {"task":"/home_act","home":{"steppers":[{"stepperid":0,"timeout":20000,"speed":5000,"direction":-1,"endstoppolarity":1}]}}\n\'\'\'\n    ESP32.home.home_x(speed =15000, direction = -1, endstoppolarity=1, timeout=1, isBlocking=True)\n    ESP32.home.home_y(speed =15000, direction = -1, endstoppolarity=-1, timeout=1, isBlocking=True)\n    ESP32.home.home_z(speed =15000, direction = 1, endstoppolarity=-1, timeout=1, isBlocking=True)\n\n    # scanning\n    dDist = 10000\n    speed = 20000\n    nDist = 4\n\n    # test Motor in scanning mode\n    ESP32.motor.move_xyza(steps=(0,0,0,0), speed=speed, is_absolute = True, is_blocking=True)\n\n    for ix in range(nDist):\n        for iy in range(nDist):\n            if ix%2==0:\n                iy=nDist-iy\n            ESP32.motor.move_xy(steps=(ix*dDist,iy*dDist), speed=speed, is_absolute = True, is_blocking=True)\n            time.sleep(0.5)\n    ESP32.motor.move_xyza(steps=(0,nDist*dDist,nDist*dDist,0), speed=speed, is_absolute = True, is_blocking=True)\n    ESP32.motor.move_xyza(steps=(0,0,0,0), speed=speed, is_absolute = True, is_blocking=True)\n\nheapSize = ESP32.state.getHeap()\nprint("Heap size: ", heapSize)\n\n# setting debug output of the serial to true - all message will be printed\nESP32.serial.DEBUG=True\nESP32.motor.move_x(steps=10000, speed=10000, is_blocking=False)\nESP32.motor.move_a(steps=10000, speed=10000, is_blocking=False)\nESP32.motor.move_z(steps=10000, speed=10000, is_blocking=True)\nESP32.motor.move_x(steps=-10000, speed=10000, is_blocking=True)\nESP32.motor.move_x(steps=10000, speed=10000, is_blocking=False)\nESP32.motor.move_xy(steps=(10000,10000), speed=(10000, 10000), is_blocking=True)\nmState = ESP32.state.get_state()\n\n\n\n\nESP32.motor.move_x(steps=10000, speed=10000, is_blocking=True)\n\n# {"task":"/ledarr_act", "led":{"LEDArrMode":1, "led_array":[{"id":0, "r":255, "g":255, "b":255}]}}\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(255, 255, 255))\nprint("Heap size: ", ESP32.state.getHeap())\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(0, 0, 0), getReturn=False)\nprint("Heap size: ", ESP32.state.getHeap())\n\n# check if we are connected \n# see if it\'s the right device\nmState = ESP32.state.get_state()\n#assert mState["state"]["identifier_name"] == "UC2_Feather", "Wrong device connected"\n\n#%% \n# test Motor\nif 0:\n    ESP32.rotator.move_x(steps=10000, speed=10000, is_blocking=True)\n    ESP32.rotator.move_y(steps=1000, speed=1000, is_blocking=True, is_enabled=False)\n    ESP32.rotator.move_z(steps=1000, speed=1000, is_blocking=True)\n    ESP32.rotator.move_y(steps=1000, speed=1000, is_blocking=True, is_enabled=False)\n    ESP32.rotator.move_t(steps=1000, speed=1000)\n    ESP32.rotator.move_xyzt(steps=(0,1000,100,0), speed=10000, is_blocking=True)\n    ESP32.rotator.move_xyzt(steps=(0,0,0,0), speed=10000, is_absolute=True, is_blocking=True)\n    ESP32.motor.move_forever(speed=(0,100,0,0), is_stop=False)\n    ESP32.motor.move_forever(speed=(0,100,0,0), is_stop=False)\n    time.sleep(1)\n\n\n\'\'\' ################\nSERIAL\n################\'\'\'\n# Write a message, get the id and read it out of the message buffer\ntest_cmd = "{\'task\': \'/motor_get\'}"\ntest_cmd = \'{"task":"/ledarr_act", "led":{"LEDArrMode":1, "led_array":[{"id":0, "r":255, "g":255, "b":255}]}}\'\nqID = ESP32.serial.writeSerial(test_cmd)\ncmd_return = ESP32.serial.readSerial(qID, 1)\nprint(cmd_return)\n\n\'\'\' ################\nDigital out\n################\'\'\'\nif(0):\n    ESP32.digitalout.setup_digitaloutpin(id=1, pin=4)\n    ESP32.digitalout.setup_digitaloutpin(id=2, pin=0)\n    ESP32.digitalout.set_trigger(trigger1=True, delayOn1=10, delayOff1=10, trigger2=True, delayOn2=100, delayOff2=10, trigger3=False, delayOn3=0, delayOff3=0)\n    time.sleep(1)\n    ESP32.digitalout.reset_triggertable()\n\n\n\n\n\n\'\'\' ################\nLED \n################\'\'\'\n# test LED\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(255, 255, 255))\nassert mResult["success"] == 1, "Failed sending LED command"\ntime.sleep(0.5)\nprint("Heap size: ", ESP32.state.getHeap())\nmResult = ESP32.led.send_LEDMatrix_full(intensity=(0, 0, 0))\nassert mResult["success"] == 1, "Failed sending LED command"\nprint("Heap size: ", ESP32.state.getHeap())\n# single LED\nESP32.setDebugging(False)\nfor iLED in range(5):\n    # timeout = 0 means no timeout => mResult will be rubish!\n    mResult = ESP32.led.send_LEDMatrix_single(indexled=iLED, intensity=(255, 255, 255), timeout=0.)\n    mResult = ESP32.led.send_LEDMatrix_single(indexled=iLED, intensity=(0, 0, 0), timeout=0.)\n\n# display random pattern\nfor i in range(5):\n    led_pattern = np.random.randint(0,55, (25,3))\n    mResult = ESP32.led.send_LEDMatrix_array(led_pattern=led_pattern,timeout=0)\n    assert mResult["success"] == 1, "Failed sending LED command"\n\ntime.sleep(3)\n#%% left\nif(0):\n    led_pattern = np.zeros((25,3))\n    list_left = (0,1,2,3,4,5,9,10,11,12,13,14,15,16,17)\n    list_right = (0,5,6,7,8,9,18,19,20,21,22,23,24)\n    led_pattern[list_left,0] = 255\n    led_pattern[list_right,1] = 255\n    ESP32.led.send_LEDMatrix_array(led_pattern=led_pattern, timeout=1)\n    time.sleep(1)\n    ESP32.led.send_LEDMatrix_array(led_pattern=led_pattern*0, timeout=1)\n\n#%%\n#%%\n\'\'\' ################\nMOTOR\n################\'\'\'\nESP32.setDebugging(True)\n\n# mResult = ESP32.motor.move_x(steps=0, is_enabled=False)\nmResult = ESP32.motor.set_motor_enable(enable=1)\nmResult = ESP32.motor.set_motor_enable(enable=0)\nassert mResult["success"] == 1, "Failed sending motor command"\n\n# test Motor\nmResult = ESP32.motor.set_position(axis=0, position=1000)\nassert mResult["success"] == 1, "Failed sending motor command"\n\nposition1 = ESP32.motor.get_position(timeout=1)\nassert position1[0]==1000, "Failed getting motor position"\nprint(position1)\nESP32.motor.set_motor_enable(enable=1, enableauto=False)# always on\nESP32.motor.move_x(steps=10000, speed=10000, is_blocking=True)\nESP32.motor.move_y(steps=1000, speed=1000, is_blocking=True, is_enabled=False)\nESP32.motor.move_z(steps=1000, speed=1000, is_blocking=True)\nESP32.motor.move_y(steps=1000, speed=1000, is_blocking=True, is_enabled=False)\nESP32.motor.move_a(steps=1000, speed=1000)\nESP32.motor.move_xyza(steps=(0,1000,100,0), speed=10000, is_blocking=True)\nESP32.motor.move_xyza(steps=(0,0,0,0), speed=10000, is_absolute=True, is_blocking=True)\nESP32.motor.move_forever(speed=(0,100,0,0), is_stop=False)\nESP32.motor.move_forever(speed=(0,100,0,0), is_stop=False)\ntime.sleep(1)\nESP32.motor.move_forever(speed=(0,0,0,0), is_stop=True)\n\nposition2 = ESP32.motor.get_position(timeout=1)\nprint(position2)\n\ndDist = 10000\nspeed = 20000\nnDist = 4\n\n# test Motor in scanning mode\nESP32.motor.move_xyza(steps=(0,0,0,0), speed=speed, is_absolute = True, is_blocking=True)\n\nfor ix in range(nDist):\n    for iy in range(nDist):\n        if ix%2==0:\n            iy=nDist-iy\n        ESP32.motor.move_xyza(steps=(0,ix*dDist,iy*dDist,0), speed=speed, is_absolute = True, is_blocking=True)\n        time.sleep(0.5)\nESP32.motor.move_xyza(steps=(0,nDist*dDist,nDist*dDist,0), speed=speed, is_absolute = True, is_blocking=True)\nESP32.motor.move_xyza(steps=(0,0,0,0), speed=speed, is_absolute = True, is_blocking=True)\n\n#%%\n\n\'\'\' ################\nanalog\n################\'\'\'\nESP32.analog.set_analog(readanaloginID=1, readanaloginPIN=35, nanaloginavg=1)\nESP32.analog.get_analog(readanaloginID=1)\n#analogValueAVG = ESP32.analog.read_sensor(sensorID=1, NAvg=100)\n#print(analogValueAVG)\n\n\n\'\'\' ################\nLASER \n################\'\'\'\n# set laser values\nESP32.laser.set_laser(channel=1, value=1000, despeckleAmplitude=0, despecklePeriod=10, timeout=20, is_blocking = True)\nESP32.laser.set_laser(channel=2, value=1000, despeckleAmplitude=0, despecklePeriod=10, timeout=20, is_blocking = True)\nESP32.laser.set_laser(channel=3, value=1000, despeckleAmplitude=0, despecklePeriod=10, timeout=20, is_blocking = True)\n\n\n\n\n\'\'\' ################\nWifi\n################\'\'\'\n# wifi\nESP32.wifi.scanWifi()\n\'\'\' ################\nState\n################\'\'\'\n# test state\n_state = ESP32.state.get_state()\nprint(_state)\nESP32.state.set_state(debug=False)\n_mode = ESP32.state.isControllerMode()\nprint(_mode)\nESP32.state.espRestart()\ntime.sleep(5)\nESP32.state.pairBT(1)\nESP32.state.setControllerMode(isController=True)\n\n\n_busy = ESP32.state.isBusy()\nprint(_busy)\n\nESP32.close()\n')),(0,i.kt)("h2",{id:"hardware-modules"},"Hardware Modules"),(0,i.kt)("h3",{id:"motor-control"},"Motor Control"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# XYZ Stage control\nclient.stage.move_x(steps=1000)\nclient.stage.move_y(steps=1000)\nclient.stage.move_z(steps=1000)\n\n# Relative positioning\nclient.stage.move_xyz(x=100, y=200, z=-50)\n\n# Absolute positioning (if homed)\nclient.stage.set_position(x=1000, y=2000, z=500)\n\n# Homing procedures\nclient.stage.home_x()\nclient.stage.home_y()\nclient.stage.home_z()\nclient.stage.home_xyz()  # Home all axes\n\n# Get current position\nposition = client.stage.get_position()\nprint(f\"Current position: X={position['x']}, Y={position['y']}, Z={position['z']}\")\n")),(0,i.kt)("h3",{id:"led-array-control"},"LED Array Control"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Single LED control\nclient.led.set_led(channel=1, intensity=100)\n\n# Multi-channel control\nclient.led.set_led_array([100, 50, 75, 0])  # Set intensities for channels 0-3\n\n# Pattern display (for LED matrix)\npattern = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\nclient.led.set_pattern(pattern)\n\n# Get LED status\nstatus = client.led.get_led_status()\nprint(f"LED status: {status}")\n')),(0,i.kt)("h3",{id:"laser-control"},"Laser Control"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Basic laser control\nclient.laser.set_laser(channel=1, intensity=25)  # 25% intensity\nclient.laser.set_laser(channel=2, intensity=100) # Full intensity\n\n# Get laser capabilities\ninfo = client.laser.get_laser_info()\nprint(f"Available lasers: {info}")\n\n# Safety shutdown\nclient.laser.turn_off_all()\n')),(0,i.kt)("h3",{id:"sensor-reading"},"Sensor Reading"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Read environmental sensors\nsensors = client.sensor.get_sensor_data()\nprint(f\"Temperature: {sensors.get('temperature', 'N/A')}\")\nprint(f\"Humidity: {sensors.get('humidity', 'N/A')}\")\n\n# Read specific sensor\ntemperature = client.sensor.get_temperature()\n")),(0,i.kt)("h2",{id:"advanced-usage"},"Advanced Usage"),(0,i.kt)("h3",{id:"configuration-management"},"Configuration Management"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Get current configuration\nconfig = client.config.get_config()\n\n# Update configuration\nnew_config = {\n    "motor": {\n        "steps_per_mm_x": 3200,\n        "steps_per_mm_y": 3200,\n        "steps_per_mm_z": 3200\n    }\n}\nclient.config.set_config(new_config)\n\n# Save configuration to flash\nclient.config.save_config()\n')),(0,i.kt)("h3",{id:"custom-commands"},"Custom Commands"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Send raw JSON command\ncommand = {\n    "task": "/motor_act",\n    "motor": 0,\n    "direction": 1,\n    "steps": 1000\n}\nresponse = client.send_command(command)\n\n# Handle response\nif response.get("return") == 1:\n    print("Command executed successfully")\nelse:\n    print(f"Command failed: {response}")\n')),(0,i.kt)("h3",{id:"error-handling"},"Error Handling"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'try:\n    client.stage.move_x(1000)\nexcept UC2RESTError as e:\n    print(f"UC2-REST error: {e}")\nexcept SerialException as e:\n    print(f"Serial communication error: {e}")\nexcept Exception as e:\n    print(f"Unexpected error: {e}")\n')),(0,i.kt)("h2",{id:"integration-with-imswitch"},"Integration with ImSwitch"),(0,i.kt)("h3",{id:"configuration-in-imswitch"},"Configuration in ImSwitch"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "rs232devices": {\n    "ESP32": {\n      "managerName": "ESP32Manager",\n      "managerProperties": {\n        "host_": "192.168.1.100",\n        "serialport": "/dev/ttyUSB0"\n      }\n    }\n  },\n  "positioners": {\n    "ESP32Stage": {\n      "managerName": "ESP32StageManager",\n      "managerProperties": {\n        "rs232device": "ESP32",\n        "stepsizeX": -0.3125,\n        "stepsizeY": -0.3125,\n        "stepsizeZ": 0.3125\n      },\n      "axes": ["X", "Y", "Z"],\n      "forScanning": true\n    }\n  }\n}\n')),(0,i.kt)("h3",{id:"imswitch-integration-examples"},"ImSwitch Integration Examples"),(0,i.kt)("p",null,"UC2-REST is integrated into ImSwitch through device managers. Here are examples based on the ImSwitch codebase:"),(0,i.kt)("h4",{id:"esp32-configuration-manager"},"ESP32 Configuration Manager"),(0,i.kt)("p",null,"Based on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openUC2/ImSwitch/blob/master/imswitch/imcontrol/model/managers/UC2ConfigManager.py"},"UC2ConfigManager.py")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openUC2/ImSwitch/blob/master/imswitch/imcontrol/model/managers/rs232/ESP32Manager.py"},"ESP32Manager.py"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from UC2REST import UC2Client\nfrom imswitch.imcontrol.model.interfaces import DeviceManager\n\nclass ESP32Manager(DeviceManager):\n    def __init__(self, deviceInfo, name, **kwargs):\n        super().__init__(deviceInfo, name, **kwargs)\n        \n        # Initialize UC2-REST client from device configuration\n        port = deviceInfo.managerProperties.get(\'port\', \'/dev/ttyUSB0\')\n        baudrate = deviceInfo.managerProperties.get(\'baudrate\', 115200)\n        \n        self.client = UC2Client(\n            serialport=port, \n            baudrate=baudrate,\n            DEBUG=False\n        )\n        \n        if not self.client.is_connected:\n            raise Exception(f"Failed to connect to ESP32 on {port}")\n    \n    def send_command(self, command_dict):\n        """Send JSON command to ESP32"""\n        return self.client.send_command(command_dict)\n    \n    def cleanup(self):\n        """Cleanup when shutting down"""\n        if hasattr(self, \'client\'):\n            self.client.close()\n')),(0,i.kt)("h4",{id:"stage-manager-integration"},"Stage Manager Integration"),(0,i.kt)("p",null,"Based on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openUC2/ImSwitch/blob/master/imswitch/imcontrol/model/managers/positioners/ESP32StageManager.py"},"ESP32StageManager.py"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from imswitch.imcontrol.model.interfaces import PositionerManager\n\nclass ESP32StageManager(PositionerManager):\n    def __init__(self, deviceInfo, name, **kwargs):\n        super().__init__(deviceInfo, name, **kwargs)\n        \n        # Get ESP32 manager instance\n        self._esp32 = kwargs[\'esp32Manager\']\n        \n        # Configure axes\n        self._axes = deviceInfo.axes\n        self._steppers = {axis: info.get(\'stepperid\', 1) \n                         for axis, info in self._axes.items()}\n    \n    def move(self, axis, position, absolute=True, blocking=True):\n        """Move stage axis to position"""\n        stepper_id = self._steppers[axis]\n        \n        command = {\n            "task": "/motor_act",\n            "motor": {\n                "steppers": [{\n                    "stepperid": stepper_id,\n                    "position": int(position),\n                    "speed": 15000,\n                    "isabs": absolute,\n                    "isblocking": blocking\n                }]\n            }\n        }\n        \n        return self._esp32.send_command(command)\n    \n    def setPosition(self, axis, position):\n        """Set current position (for calibration)"""\n        stepper_id = self._steppers[axis]\n        \n        command = {\n            "task": "/motor_set",\n            "motor": {\n                "steppers": [{\n                    "stepperid": stepper_id,\n                    "position": int(position)\n                }]\n            }\n        }\n        \n        return self._esp32.send_command(command)\n')),(0,i.kt)("h4",{id:"led-manager-integration"},"LED Manager Integration"),(0,i.kt)("p",null,"Based on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openUC2/ImSwitch/blob/master/imswitch/imcontrol/model/managers/LEDMatrixs/ESP32LEDMatrixManager.py"},"ESP32LEDMatrixManager.py"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from imswitch.imcontrol.model.interfaces import LEDMatrixManager\n\nclass ESP32LEDManager(LEDMatrixManager):\n    def __init__(self, deviceInfo, name, **kwargs):\n        super().__init__(deviceInfo, name, **kwargs)\n        \n        self._esp32 = kwargs[\'esp32Manager\']\n        self._channels = deviceInfo.managerProperties.get(\'channels\', [1, 2, 3])\n    \n    def setLED(self, channel, intensity):\n        """Set LED intensity (0-255)"""\n        command = {\n            "task": "/led_act",\n            "led": {\n                "LEDArrMode": 1,\n                "led_array": [\n                    {\n                        "id": channel,\n                        "r": int(intensity),\n                        "g": int(intensity), \n                        "b": int(intensity)\n                    }\n                ]\n            }\n        }\n        \n        return self._esp32.send_command(command)\n    \n    def setPattern(self, pattern_array):\n        """Set LED pattern for matrix"""\n        led_commands = []\n        for i, intensity in enumerate(pattern_array):\n            led_commands.append({\n                "id": i + 1,\n                "r": int(intensity),\n                "g": int(intensity),\n                "b": int(intensity)\n            })\n        \n        command = {\n            "task": "/led_act",\n            "led": {\n                "LEDArrMode": 1,\n                "led_array": led_commands\n            }\n        }\n        \n        return self._esp32.send_command(command)\n')),(0,i.kt)("h4",{id:"laser-manager-integration"},"Laser Manager Integration"),(0,i.kt)("p",null,"Based on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openUC2/ImSwitch/blob/master/imswitch/imcontrol/model/managers/lasers/ESP32LEDLaserManager.py"},"ESP32LEDLaserManager.py"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from imswitch.imcontrol.model.interfaces import LaserManager\n\nclass ESP32LaserManager(LaserManager):\n    def __init__(self, deviceInfo, name, **kwargs):\n        super().__init__(deviceInfo, name, **kwargs)\n        \n        self._esp32 = kwargs[\'esp32Manager\']\n        self._channel = deviceInfo.managerProperties.get(\'channel\', 1)\n        self._maxPower = deviceInfo.managerProperties.get(\'maxPower\', 255)\n    \n    def setValue(self, power):\n        """Set laser power (0-100%)"""\n        intensity = int((power / 100.0) * self._maxPower)\n        \n        command = {\n            "task": "/laser_act",\n            "laser": {\n                "LASERid": self._channel,\n                "LASERval": intensity\n            }\n        }\n        \n        return self._esp32.send_command(command)\n    \n    def setEnabled(self, enabled):\n        """Enable/disable laser"""\n        if enabled:\n            self.setValue(self._lastPower if hasattr(self, \'_lastPower\') else 50)\n        else:\n            self._lastPower = self.getValue()\n            self.setValue(0)\n')),(0,i.kt)("h4",{id:"custom-device-manager-template"},"Custom Device Manager Template"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from UC2REST import UC2Client\nfrom imswitch.imcontrol.model.interfaces import DeviceManager\n\nclass CustomUC2Manager(DeviceManager):\n    def __init__(self, deviceInfo, name, **kwargs):\n        super().__init__(deviceInfo, name, **kwargs)\n        \n        # Initialize UC2-REST client\n        self.client = UC2Client(\n            serialport=deviceInfo.managerProperties.get(\'serialport\'),\n            host=deviceInfo.managerProperties.get(\'host\')\n        )\n    \n    def move_stage(self, x, y, z):\n        """Custom stage movement with UC2-REST"""\n        self.client.stage.move_xyz(x=x, y=y, z=z)\n')),(0,i.kt)("h2",{id:"communication-protocols"},"Communication Protocols"),(0,i.kt)("h3",{id:"usb-serial-protocol"},"USB Serial Protocol"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Configure serial parameters\nclient = UC2Client(\n    serialport="/dev/ttyUSB0",\n    baudrate=115200,\n    timeout=1.0\n)\n\n# JSON message format\nmessage = {\n    "task": "/led_act",\n    "led": {"channel": 1, "intensity": 100}\n}\n')),(0,i.kt)("h3",{id:"wifihttp-protocol"},"WiFi/HTTP Protocol"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Configure WiFi parameters\nclient = UC2Client(\n    host="192.168.1.100",\n    port=31950,\n    timeout=5.0\n)\n\n# HTTP endpoints\n# GET: http://192.168.1.100:31950/state_get\n# POST: http://192.168.1.100:31950/led_act\n')),(0,i.kt)("h2",{id:"troubleshooting"},"Troubleshooting"),(0,i.kt)("h3",{id:"connection-issues"},"Connection Issues"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Check serial ports\nimport serial.tools.list_ports\nports = serial.tools.list_ports.comports()\nfor port in ports:\n    print(f"Port: {port.device}, Description: {port.description}")\n\n# Test connection\ntry:\n    client = UC2Client(serialport="/dev/ttyUSB0")\n    if client.is_connected:\n        print("Connection successful")\n    else:\n        print("Connection failed")\nexcept Exception as e:\n    print(f"Connection error: {e}")\n')),(0,i.kt)("h3",{id:"command-debugging"},"Command Debugging"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# Enable debug output\nclient = UC2Client(serialport="/dev/ttyUSB0", DEBUG=True)\n\n# All commands and responses will be printed to console\nclient.stage.move_x(1000)\n')),(0,i.kt)("h3",{id:"common-error-solutions"},"Common Error Solutions"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Serial port permission denied:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Add user to dialout group\nsudo usermod -a -G dialout $USER\n# Logout and login again\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"ESP32 not responding:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Check power supply and connections"),(0,i.kt)("li",{parentName:"ol"},"Verify correct COM port/device"),(0,i.kt)("li",{parentName:"ol"},"Reset ESP32 (press reset button)"),(0,i.kt)("li",{parentName:"ol"},"Re-flash firmware if necessary")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"WiFi connection timeout:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Verify ESP32 is connected to network"),(0,i.kt)("li",{parentName:"ol"},"Check IP address with router/network scan"),(0,i.kt)("li",{parentName:"ol"},"Ensure firewall allows port 31950"),(0,i.kt)("li",{parentName:"ol"},"Try different network settings")),(0,i.kt)("h2",{id:"examples-and-scripts"},"Examples and Scripts"),(0,i.kt)("h3",{id:"complete-setup-example"},"Complete Setup Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#!/usr/bin/env python3\n"""\nComplete UC2-REST setup example\n"""\nfrom UC2REST import UC2Client\nimport time\n\ndef main():\n    # Initialize client\n    client = UC2Client(serialport="/dev/ttyUSB0")\n    \n    if not client.is_connected:\n        print("Failed to connect to UC2-ESP32")\n        return\n    \n    try:\n        # Initialize system\n        print("Initializing UC2 system...")\n        \n        # Home all axes\n        print("Homing stages...")\n        client.stage.home_xyz()\n        time.sleep(5)  # Wait for homing to complete\n        \n        # Set up illumination\n        print("Setting up LED array...")\n        client.led.set_led_array([50, 100, 75, 25])\n        \n        # Test stage movement\n        print("Testing stage movement...")\n        client.stage.move_xyz(x=1000, y=1000, z=0)\n        time.sleep(2)\n        \n        # Return to center\n        client.stage.move_xyz(x=-1000, y=-1000, z=0)\n        \n        # Turn off all illumination\n        client.led.set_led_array([0, 0, 0, 0])\n        client.laser.turn_off_all()\n        \n        print("UC2 setup complete!")\n        \n    except Exception as e:\n        print(f"Error during setup: {e}")\n    \n    finally:\n        # Cleanup\n        client.close()\n\nif __name__ == "__main__":\n    main()\n')),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"/docs/ImSwitch/Advanced/Usage/Micromanager"},"Micromanager Integration"))," - Use UC2-REST with \xb5Manager"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"../04_Tutorials/Scripting.md"},"Custom Scripts"))," - Write custom automation scripts"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"../03_Configuration/Hardware.md"},"Hardware Configuration"))," - Configure specific devices"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"../../04_Electronics/UC2-ESP/"},"ESP32 Firmware"))," - UC2-ESP32 firmware documentation")),(0,i.kt)("h2",{id:"related-resources"},"Related Resources"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openUC2/UC2-REST"},"UC2-REST Repository"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/youseetoo/uc2-esp32"},"UC2-ESP32 Firmware"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://imswitch.readthedocs.io/"},"ImSwitch Documentation"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openUC2/UC2-REST/blob/master/docs/API.md"},"API Reference")))))}c.isMDXComponent=!0}}]);